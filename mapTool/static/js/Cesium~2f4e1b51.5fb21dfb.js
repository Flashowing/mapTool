(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~2f4e1b51"],{"4b3a":function(e,t,n){"use strict";const i={READY:0,CREATING:1,CREATED:2,COMBINING:3,COMBINED:4,COMPLETE:5,FAILED:6};t["a"]=Object.freeze(i)},"738d":function(e,t,n){"use strict";var i=n("71ce"),a=n("535a"),o=n("2f63"),r=n("7d62");function s(e){e=Object(a["a"])(e,a["a"].EMPTY_OBJECT),this._primitives=[],this._guid=Object(i["a"])(),this._zIndex=void 0,this.show=Object(a["a"])(e.show,!0),this.destroyPrimitives=Object(a["a"])(e.destroyPrimitives,!0)}function c(e,t){return e._primitives.indexOf(t)}Object.defineProperties(s.prototype,{length:{get:function(){return this._primitives.length}}}),s.prototype.add=function(e,t){const n=Object(o["a"])(t),i=e._external=e._external||{},a=i._composites=i._composites||{};return a[this._guid]={collection:this},n?this._primitives.splice(t,0,e):this._primitives.push(e),e},s.prototype.remove=function(e){if(this.contains(e)){const t=this._primitives.indexOf(e);if(-1!==t)return this._primitives.splice(t,1),delete e._external._composites[this._guid],this.destroyPrimitives&&e.destroy(),!0}return!1},s.prototype.removeAndDestroy=function(e){const t=this.remove(e);return t&&!this.destroyPrimitives&&e.destroy(),t},s.prototype.removeAll=function(){const e=this._primitives,t=e.length;for(let n=0;n<t;++n)delete e[n]._external._composites[this._guid],this.destroyPrimitives&&e[n].destroy();this._primitives=[]},s.prototype.contains=function(e){return!!(Object(o["a"])(e)&&e._external&&e._external._composites&&e._external._composites[this._guid])},s.prototype.raise=function(e){if(Object(o["a"])(e)){const t=c(this,e),n=this._primitives;if(t!==n.length-1){const e=n[t];n[t]=n[t+1],n[t+1]=e}}},s.prototype.raiseToTop=function(e){if(Object(o["a"])(e)){const t=c(this,e),n=this._primitives;t!==n.length-1&&(n.splice(t,1),n.push(e))}},s.prototype.lower=function(e){if(Object(o["a"])(e)){const t=c(this,e),n=this._primitives;if(0!==t){const e=n[t];n[t]=n[t-1],n[t-1]=e}}},s.prototype.lowerToBottom=function(e){if(Object(o["a"])(e)){const t=c(this,e),n=this._primitives;0!==t&&(n.splice(t,1),n.unshift(e))}},s.prototype.get=function(e){return this._primitives[e]},s.prototype.update=function(e){if(!this.show)return;const t=this._primitives;for(let n=0;n<t.length;++n)t[n].update(e)},s.prototype.prePassesUpdate=function(e){const t=this._primitives;for(let n=0;n<t.length;++n){const i=t[n];Object(o["a"])(i.prePassesUpdate)&&i.prePassesUpdate(e)}},s.prototype.updateForPass=function(e,t){const n=this._primitives;for(let i=0;i<n.length;++i){const a=n[i];Object(o["a"])(a.updateForPass)&&a.updateForPass(e,t)}},s.prototype.postPassesUpdate=function(e){const t=this._primitives;for(let n=0;n<t.length;++n){const i=t[n];Object(o["a"])(i.postPassesUpdate)&&i.postPassesUpdate(e)}},s.prototype.isDestroyed=function(){return!1},s.prototype.destroy=function(){return this.removeAll(),Object(r["a"])(this)},t["a"]=s},8624:function(e,t,n){"use strict";var i=n("cef5"),a=n("abab"),o=n("535a"),r=n("2f63"),s=n("c52f"),c=n("3d7f"),p=n("d2c7"),h=n("81d7"),u=n("473c"),d=n("c1e2"),l=n("0123"),b=n("52f0"),m=n("c2eb"),f=n("1184");function _(e,t,n){let i=!n;const a=e.length;let o;if(!i&&a>1){const t=e[0].modelMatrix;for(o=1;o<a;++o)if(!b["a"].equals(t,e[o].modelMatrix)){i=!0;break}}if(i)for(o=0;o<a;++o)Object(r["a"])(e[o].geometry)&&d["a"].transformToWorldCoordinates(e[o]);else b["a"].multiplyTransformation(t,e[0].modelMatrix,t)}function g(e,t){const n=e.attributes,i=n.position,o=i.values.length/i.componentsPerAttribute;n.batchId=new h["a"]({componentDatatype:a["a"].FLOAT,componentsPerAttribute:1,values:new Float32Array(o)});const r=n.batchId.values;for(let a=0;a<o;++a)r[a]=t}function y(e){const t=e.length;for(let n=0;n<t;++n){const t=e[n];Object(r["a"])(t.geometry)?g(t.geometry,n):Object(r["a"])(t.westHemisphereGeometry)&&Object(r["a"])(t.eastHemisphereGeometry)&&(g(t.westHemisphereGeometry,n),g(t.eastHemisphereGeometry,n))}}function O(e){const t=e.instances,n=e.projection,o=e.elementIndexUintSupported,s=e.scene3DOnly,c=e.vertexCacheOptimize,p=e.compressVertices,h=e.modelMatrix;let u,l,b,m=t.length;for(u=0;u<m;++u)if(Object(r["a"])(t[u].geometry)){b=t[u].geometry.primitiveType;break}if(_(t,h,s),!s)for(u=0;u<m;++u)Object(r["a"])(t[u].geometry)&&d["a"].splitLongitude(t[u]);if(y(t),c)for(u=0;u<m;++u){const e=t[u];Object(r["a"])(e.geometry)?(d["a"].reorderForPostVertexCache(e.geometry),d["a"].reorderForPreVertexCache(e.geometry)):Object(r["a"])(e.westHemisphereGeometry)&&Object(r["a"])(e.eastHemisphereGeometry)&&(d["a"].reorderForPostVertexCache(e.westHemisphereGeometry),d["a"].reorderForPreVertexCache(e.westHemisphereGeometry),d["a"].reorderForPostVertexCache(e.eastHemisphereGeometry),d["a"].reorderForPreVertexCache(e.eastHemisphereGeometry))}let f=d["a"].combineInstances(t);for(m=f.length,u=0;u<m;++u){l=f[u];const e=l.attributes;if(s)for(const t in e)e.hasOwnProperty(t)&&e[t].componentDatatype===a["a"].DOUBLE&&d["a"].encodeAttribute(l,t,t+"3DHigh",t+"3DLow");else for(const t in e)if(e.hasOwnProperty(t)&&e[t].componentDatatype===a["a"].DOUBLE){const e=t+"3D",a=t+"2D";d["a"].projectTo2D(l,t,e,a,n),Object(r["a"])(l.boundingSphere)&&"position"===t&&(l.boundingSphereCV=i["a"].fromVertices(l.attributes.position2D.values)),d["a"].encodeAttribute(l,e,e+"High",e+"Low"),d["a"].encodeAttribute(l,a,a+"High",a+"Low")}p&&d["a"].compressVertices(l)}if(!o){let e=[];for(m=f.length,u=0;u<m;++u)l=f[u],e=e.concat(d["a"].fitToUnsignedShortIndices(l));f=e}return f}function S(e,t,n,i){let a,o,s;const c=i.length-1;if(c>=0){const e=i[c];a=e.offset+e.count,s=e.index,o=n[s].indices.length}else a=0,s=0,o=n[s].indices.length;const p=e.length;for(let h=0;h<p;++h){const c=e[h],p=c[t];if(!Object(r["a"])(p))continue;const u=p.indices.length;a+u>o&&(a=0,o=n[++s].indices.length),i.push({index:s,offset:a,count:u}),a+=u}}function v(e,t){const n=[];return S(e,"geometry",t,n),S(e,"westHemisphereGeometry",t,n),S(e,"eastHemisphereGeometry",t,n),n}const C={};function T(e,t){const n=e.attributes;for(const i in n)if(n.hasOwnProperty(i)){const e=n[i];Object(r["a"])(e)&&Object(r["a"])(e.values)&&t.push(e.values.buffer)}Object(r["a"])(e.indices)&&t.push(e.indices.buffer)}function D(e,t){const n=e.length;for(let i=0;i<n;++i)T(e[i],t)}function A(e){let t=1;const n=e.length;for(let a=0;a<n;a++){const n=e[a];if(++t,!Object(r["a"])(n))continue;const o=n.attributes;t+=7+2*i["a"].packedLength+(Object(r["a"])(n.indices)?n.indices.length:0);for(const e in o)if(o.hasOwnProperty(e)&&Object(r["a"])(o[e])){const n=o[e];t+=5+n.values.length}}return t}function w(e,t){const n=e.length,i=new Float64Array(1+19*n);let a=0;i[a++]=n;for(let o=0;o<n;o++){const t=e[o];if(b["a"].pack(t.modelMatrix,i,a),a+=b["a"].packedLength,Object(r["a"])(t.attributes)&&Object(r["a"])(t.attributes.offset)){const e=t.attributes.offset.value;i[a]=e[0],i[a+1]=e[1],i[a+2]=e[2]}a+=3}return t.push(i.buffer),i}function j(e){const t=e,n=new Array(t[0]);let i=0,a=1;while(a<t.length){const e=b["a"].unpack(t,a);let o;a+=b["a"].packedLength,Object(r["a"])(t[a])&&(o={offset:new m["a"](t[a],t[a+1],t[a+2])}),a+=3,n[i++]={modelMatrix:e,attributes:o}}return n}function x(e){const t=e.length,n=1+(i["a"].packedLength+1)*t,a=new Float32Array(n);let o=0;a[o++]=t;for(let s=0;s<t;++s){const t=e[s];Object(r["a"])(t)?(a[o++]=1,i["a"].pack(e[s],a,o)):a[o++]=0,o+=i["a"].packedLength}return a}function I(e){const t=new Array(e[0]);let n=0,a=1;while(a<e.length)1===e[a++]&&(t[n]=i["a"].unpack(e,a)),++n,a+=i["a"].packedLength;return t}C.combineGeometry=function(e){let t,n;const a=e.instances,o=a.length;let s,c,p=!1;o>0&&(t=O(e),t.length>0&&(n=d["a"].createAttributeLocations(t[0]),e.createPickOffsets&&(s=v(a,t))),Object(r["a"])(a[0].attributes)&&Object(r["a"])(a[0].attributes.offset)&&(c=new Array(o),p=!0));const h=new Array(o),u=new Array(o);for(let d=0;d<o;++d){const e=a[d],t=e.geometry;Object(r["a"])(t)&&(h[d]=t.boundingSphere,u[d]=t.boundingSphereCV,p&&(c[d]=e.geometry.offsetAttribute));const n=e.eastHemisphereGeometry,o=e.westHemisphereGeometry;Object(r["a"])(n)&&Object(r["a"])(o)&&(Object(r["a"])(n.boundingSphere)&&Object(r["a"])(o.boundingSphere)&&(h[d]=i["a"].union(n.boundingSphere,o.boundingSphere)),Object(r["a"])(n.boundingSphereCV)&&Object(r["a"])(o.boundingSphereCV)&&(u[d]=i["a"].union(n.boundingSphereCV,o.boundingSphereCV)))}return{geometries:t,modelMatrix:e.modelMatrix,attributeLocations:n,pickOffsets:s,offsetInstanceExtend:c,boundingSpheres:h,boundingSpheresCV:u}},C.packCreateGeometryResults=function(e,t){const n=new Float64Array(A(e)),a=[],s={},c=e.length;let p=0;n[p++]=c;for(let h=0;h<c;h++){const t=e[h],c=Object(r["a"])(t);if(n[p++]=c?1:0,!c)continue;n[p++]=t.primitiveType,n[p++]=t.geometryType,n[p++]=Object(o["a"])(t.offsetAttribute,-1);const u=Object(r["a"])(t.boundingSphere)?1:0;n[p++]=u,u&&i["a"].pack(t.boundingSphere,n,p),p+=i["a"].packedLength;const d=Object(r["a"])(t.boundingSphereCV)?1:0;n[p++]=d,d&&i["a"].pack(t.boundingSphereCV,n,p),p+=i["a"].packedLength;const l=t.attributes,b=[];for(const e in l)l.hasOwnProperty(e)&&Object(r["a"])(l[e])&&(b.push(e),Object(r["a"])(s[e])||(s[e]=a.length,a.push(e)));n[p++]=b.length;for(let e=0;e<b.length;e++){const t=b[e],i=l[t];n[p++]=s[t],n[p++]=i.componentDatatype,n[p++]=i.componentsPerAttribute,n[p++]=i.normalize?1:0,n[p++]=i.values.length,n.set(i.values,p),p+=i.values.length}const m=Object(r["a"])(t.indices)?t.indices.length:0;n[p++]=m,m>0&&(n.set(t.indices,p),p+=m)}return t.push(n.buffer),{stringTable:a,packedData:n}},C.unpackCreateGeometryResults=function(e){const t=e.stringTable,n=e.packedData;let o;const r=new Array(n[0]);let s=0,c=1;while(c<n.length){const e=1===n[c++];if(!e){r[s++]=void 0;continue}const d=n[c++],b=n[c++];let m,f,_=n[c++];-1===_&&(_=void 0);const g=1===n[c++];g&&(m=i["a"].unpack(n,c)),c+=i["a"].packedLength;const y=1===n[c++];let O,S,v;y&&(f=i["a"].unpack(n,c)),c+=i["a"].packedLength;const C=new u["a"],T=n[c++];for(o=0;o<T;o++){const e=t[n[c++]],i=n[c++];v=n[c++];const o=0!==n[c++];O=n[c++],S=a["a"].createTypedArray(i,O);for(let t=0;t<O;t++)S[t]=n[c++];C[e]=new h["a"]({componentDatatype:i,componentsPerAttribute:v,normalize:o,values:S})}let D;if(O=n[c++],O>0){const e=S.length/v;for(D=l["a"].createTypedArray(e,O),o=0;o<O;o++)D[o]=n[c++]}r[s++]=new p["a"]({primitiveType:d,geometryType:b,boundingSphere:m,boundingSphereCV:f,indices:D,attributes:C,offsetAttribute:_})}return r},C.packCombineGeometryParameters=function(e,t){const n=e.createGeometryResults,i=n.length;for(let a=0;a<i;a++)t.push(n[a].packedData.buffer);return{createGeometryResults:e.createGeometryResults,packedInstances:w(e.instances,t),ellipsoid:e.ellipsoid,isGeographic:e.projection instanceof c["a"],elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e.createPickOffsets}},C.unpackCombineGeometryParameters=function(e){const t=j(e.packedInstances),n=e.createGeometryResults,i=n.length;let a=0;for(let s=0;s<i;s++){const e=C.unpackCreateGeometryResults(n[s]),i=e.length;for(let n=0;n<i;n++){const i=e[n],o=t[a];o.geometry=i,++a}}const o=s["a"].clone(e.ellipsoid),r=e.isGeographic?new c["a"](o):new f["a"](o);return{instances:t,ellipsoid:o,projection:r,elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:b["a"].clone(e.modelMatrix),createPickOffsets:e.createPickOffsets}},C.packCombineGeometryResults=function(e,t){Object(r["a"])(e.geometries)&&D(e.geometries,t);const n=x(e.boundingSpheres),i=x(e.boundingSpheresCV);return t.push(n.buffer,i.buffer),{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:n,boundingSpheresCV:i}},C.unpackCombineGeometryResults=function(e){return{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:I(e.boundingSpheres),boundingSpheresCV:I(e.boundingSpheresCV)}},t["a"]=C},"894b":function(e,t,n){"use strict";var i=n("cef5"),a=n("670c"),o=n("be18"),r=n("a561"),s=n("bef8"),c=n("dc1c"),p=n("bd8d"),h=n("2bb9"),u=n("abab"),d=n("535a"),l=n("9c35"),b=n("2f63"),m=n("7d62"),f=n("6cbd"),_=n("5e57"),g=n("d2c7"),y=n("81d7"),O=n("473c"),S=n("0276"),v=n("66bf"),C=n("52f0"),T=n("188e"),D=n("283e"),A=n("6a4b"),w=n("6a29"),j=n("8b68"),x=n("b997"),I=n("a894"),P=n("d289"),k=n("6dc0"),z=n("e90c"),F=n("5770"),E=n("7c5e"),L=n("2cc3"),M=n("29ab"),R=n("06f0"),B=n("8624"),V=n("4b3a"),G=n("a307"),H=n("c86b");function $(e){e=Object(d["a"])(e,d["a"].EMPTY_OBJECT),this.geometryInstances=e.geometryInstances,this.appearance=e.appearance,this._appearance=void 0,this._material=void 0,this.depthFailAppearance=e.depthFailAppearance,this._depthFailAppearance=void 0,this._depthFailMaterial=void 0,this.modelMatrix=C["a"].clone(Object(d["a"])(e.modelMatrix,C["a"].IDENTITY)),this._modelMatrix=new C["a"],this.show=Object(d["a"])(e.show,!0),this._vertexCacheOptimize=Object(d["a"])(e.vertexCacheOptimize,!1),this._interleave=Object(d["a"])(e.interleave,!1),this._releaseGeometryInstances=Object(d["a"])(e.releaseGeometryInstances,!0),this._allowPicking=Object(d["a"])(e.allowPicking,!0),this._asynchronous=Object(d["a"])(e.asynchronous,!0),this._compressVertices=Object(d["a"])(e.compressVertices,!0),this.cull=Object(d["a"])(e.cull,!0),this.debugShowBoundingVolume=Object(d["a"])(e.debugShowBoundingVolume,!1),this.rtcCenter=e.rtcCenter,this.shadows=Object(d["a"])(e.shadows,H["a"].DISABLED),this._translucent=void 0,this._state=V["a"].READY,this._geometries=[],this._error=void 0,this._numberOfInstances=0,this._boundingSpheres=[],this._boundingSphereWC=[],this._boundingSphereCV=[],this._boundingSphere2D=[],this._boundingSphereMorph=[],this._perInstanceAttributeCache=[],this._instanceIds=[],this._lastPerInstanceAttributeIndex=0,this._va=[],this._attributeLocations=void 0,this._primitiveType=void 0,this._frontFaceRS=void 0,this._backFaceRS=void 0,this._sp=void 0,this._depthFailAppearance=void 0,this._spDepthFail=void 0,this._frontFaceDepthFailRS=void 0,this._backFaceDepthFailRS=void 0,this._pickIds=[],this._colorCommands=[],this._pickCommands=[],this._createBoundingVolumeFunction=e._createBoundingVolumeFunction,this._createRenderStatesFunction=e._createRenderStatesFunction,this._createShaderProgramFunction=e._createShaderProgramFunction,this._createCommandsFunction=e._createCommandsFunction,this._updateAndQueueCommandsFunction=e._updateAndQueueCommandsFunction,this._createPickOffsets=e._createPickOffsets,this._pickOffsets=void 0,this._createGeometryResults=void 0,this._ready=!1,this._readyPromise=Object(l["a"])(),this._batchTable=void 0,this._batchTableAttributeIndices=void 0,this._offsetInstanceExtend=void 0,this._batchTableOffsetAttribute2DIndex=void 0,this._batchTableOffsetsUpdated=!1,this._instanceBoundingSpheres=void 0,this._instanceBoundingSpheresCV=void 0,this._tempBoundingSpheres=void 0,this._recomputeBoundingSpheres=!1,this._batchTableBoundingSpheresUpdated=!1,this._batchTableBoundingSphereAttributeIndices=void 0}function N(e){const t=e.length,n=[],i=e[0].attributes;let a;for(a in i)if(i.hasOwnProperty(a)&&Object(b["a"])(i[a])){const o=i[a];let r=!0;for(let n=1;n<t;++n){const t=e[n].attributes[a];if(!Object(b["a"])(t)||o.componentDatatype!==t.componentDatatype||o.componentsPerAttribute!==t.componentsPerAttribute||o.normalize!==t.normalize){r=!1;break}}r&&n.push(a)}return n}Object.defineProperties($.prototype,{vertexCacheOptimize:{get:function(){return this._vertexCacheOptimize}},interleave:{get:function(){return this._interleave}},releaseGeometryInstances:{get:function(){return this._releaseGeometryInstances}},allowPicking:{get:function(){return this._allowPicking}},asynchronous:{get:function(){return this._asynchronous}},compressVertices:{get:function(){return this._compressVertices}},ready:{get:function(){return this._ready}},readyPromise:{get:function(){return this._readyPromise.promise}}});const U=new a["a"],q=new o["a"],W=new r["a"];function Y(e){const t=e.length;return 1===t?e[0]:2===t?a["a"].unpack(e,0,U):3===t?o["a"].unpack(e,0,q):4===t?r["a"].unpack(e,0,W):void 0}function J(e,t){const n=e.geometryInstances,i=Array.isArray(n)?n:[n],a=i.length;if(0===a)return;const o=N(i),r=o.length,s=[],c={},h={};let l;const m=i[0];let f,_,g,y=m.attributes;for(f=0;f<r;++f)_=o[f],g=y[_],c[_]=f,s.push({functionName:"czm_batchTable_"+_,componentDatatype:g.componentDatatype,componentsPerAttribute:g.componentsPerAttribute,normalize:g.normalize});-1!==o.indexOf("distanceDisplayCondition")&&(s.push({functionName:"czm_batchTable_boundingSphereCenter3DHigh",componentDatatype:u["a"].FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter3DLow",componentDatatype:u["a"].FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter2DHigh",componentDatatype:u["a"].FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereCenter2DLow",componentDatatype:u["a"].FLOAT,componentsPerAttribute:3},{functionName:"czm_batchTable_boundingSphereRadius",componentDatatype:u["a"].FLOAT,componentsPerAttribute:1}),h.center3DHigh=s.length-5,h.center3DLow=s.length-4,h.center2DHigh=s.length-3,h.center2DLow=s.length-2,h.radius=s.length-1),-1!==o.indexOf("offset")&&(s.push({functionName:"czm_batchTable_offset2D",componentDatatype:u["a"].FLOAT,componentsPerAttribute:3}),l=s.length-1),s.push({functionName:"czm_batchTable_pickColor",componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:4,normalize:!0});const O=s.length,S=new L["a"](t,s,a);for(f=0;f<a;++f){const n=i[f];y=n.attributes;for(let e=0;e<r;++e){_=o[e],g=y[_];const t=Y(g.value),n=c[_];S.setBatchedAttribute(f,n,t)}const a={primitive:Object(d["a"])(n.pickPrimitive,e)};Object(b["a"])(n.id)&&(a.id=n.id);const s=t.createPickId(a);e._pickIds.push(s);const h=s.color,u=W;u.x=p["a"].floatToByte(h.red),u.y=p["a"].floatToByte(h.green),u.z=p["a"].floatToByte(h.blue),u.w=p["a"].floatToByte(h.alpha),S.setBatchedAttribute(f,O-1,u)}e._batchTable=S,e._batchTableAttributeIndices=c,e._batchTableBoundingSphereAttributeIndices=h,e._batchTableOffsetAttribute2DIndex=l}function Q(e){let t;return t=Array.isArray(e.values)?e.values.slice(0):new e.values.constructor(e.values),new y["a"]({componentDatatype:e.componentDatatype,componentsPerAttribute:e.componentsPerAttribute,normalize:e.normalize,values:t})}function X(e){const t=e.attributes,n=new O["a"];for(const i in t)t.hasOwnProperty(i)&&Object(b["a"])(t[i])&&(n[i]=Q(t[i]));let a;if(Object(b["a"])(e.indices)){const t=e.indices;a=Array.isArray(t)?t.slice(0):new t.constructor(t)}return new g["a"]({attributes:n,indices:a,primitiveType:e.primitiveType,boundingSphere:i["a"].clone(e.boundingSphere)})}function Z(e,t){return{geometry:t,attributes:e.attributes,modelMatrix:C["a"].clone(e.modelMatrix),pickPrimitive:e.pickPrimitive,id:e.id}}const K=/attribute\s+vec(?:3|4)\s+(.*)3DHigh;/g;function ee(e){const t=F["a"].replaceMain(e,"czm_non_pick_main"),n="varying vec4 v_pickColor; \nvoid main() \n{ \n    czm_non_pick_main(); \n    v_pickColor = czm_batchTable_pickColor(batchId); \n}";return`${t}\n${n}`}function te(e){return"varying vec4 v_pickColor;\n"+e}function ne(e,t){if(!e.compressVertices)return t;const n=-1!==t.search(/attribute\s+vec3\s+normal;/g),i=-1!==t.search(/attribute\s+vec2\s+st;/g);if(!n&&!i)return t;const a=-1!==t.search(/attribute\s+vec3\s+tangent;/g),o=-1!==t.search(/attribute\s+vec3\s+bitangent;/g);let r=i&&n?2:1;r+=a||o?1:0;const s=r>1?"vec"+r:"float",c="compressedAttributes",p=`attribute ${s} ${c};`;let h="",u="";if(i){h+="vec2 st;\n";const e=r>1?c+".x":c;u+=`    st = czm_decompressTextureCoordinates(${e});\n`}n&&a&&o?(h+="vec3 normal;\nvec3 tangent;\nvec3 bitangent;\n",u+=`    czm_octDecode(${c}.${i?"yz":"xy"}, normal, tangent, bitangent);\n`):(n&&(h+="vec3 normal;\n",u+=`    normal = czm_octDecode(${c}${r>1?"."+(i?"y":"x"):""});\n`),a&&(h+="vec3 tangent;\n",u+=`    tangent = czm_octDecode(${c}.${i&&n?"z":"y"});\n`),o&&(h+="vec3 bitangent;\n",u+=`    bitangent = czm_octDecode(${c}.${i&&n?"z":"y"});\n`));let d=t;d=d.replace(/attribute\s+vec3\s+normal;/g,""),d=d.replace(/attribute\s+vec2\s+st;/g,""),d=d.replace(/attribute\s+vec3\s+tangent;/g,""),d=d.replace(/attribute\s+vec3\s+bitangent;/g,""),d=F["a"].replaceMain(d,"czm_non_compressed_main");const l=`void main() \n{ \n${u}    czm_non_compressed_main(); \n}`;return[p,h,d,l].join("\n")}function ie(e){let t=F["a"].replaceMain(e,"czm_non_depth_clamp_main");return t+="void main() {\n    czm_non_depth_clamp_main();\n    gl_Position = czm_depthClamp(gl_Position);}\n",t}function ae(e){let t=F["a"].replaceMain(e,"czm_non_depth_clamp_main");return t+="void main() {\n    czm_non_depth_clamp_main();\n#if defined(GL_EXT_frag_depth)\n    #if defined(LOG_DEPTH)\n        czm_writeLogDepth();\n    #else\n        czm_writeDepthClamp();\n    #endif\n#endif\n}\n",t="#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n#endif\n"+t,t}function oe(e,t){e.vertexAttributes}function re(e,t){return function(){return e[t]}}$._modifyShaderPosition=function(e,t,n){let i,a="",o="",r="";while(null!==(i=K.exec(t))){const s=i[1],c=`vec4 czm_compute${s[0].toUpperCase()}${s.substr(1)}()`;"vec4 czm_computePosition()"!==c&&(a+=c+";\n"),Object(b["a"])(e.rtcCenter)?(t=t.replace(/attribute\s+vec(?:3|4)\s+position3DHigh;/g,""),t=t.replace(/attribute\s+vec(?:3|4)\s+position3DLow;/g,""),a+="uniform mat4 u_modifiedModelView;\n",o+="attribute vec4 position;\n",r+=c+"\n{\n    return u_modifiedModelView * position;\n}\n\n",t=t.replace(/czm_modelViewRelativeToEye\s+\*\s+/g,""),t=t.replace(/czm_modelViewProjectionRelativeToEye/g,"czm_projection")):n?r+=c+"\n{\n"+`    return czm_translateRelativeToEye(${s}3DHigh, ${s}3DLow);\n}\n\n`:(o+=`attribute vec3 ${s}2DHigh;\nattribute vec3 ${s}2DLow;\n`,r+=c+"\n{\n    vec4 p;\n    if (czm_morphTime == 1.0)\n    {\n"+`        p = czm_translateRelativeToEye(${s}3DHigh, ${s}3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n`+`        p = czm_translateRelativeToEye(${s}2DHigh.zxy, ${s}2DLow.zxy);\n    }\n    else\n    {\n        p = czm_columbusViewMorph(\n`+`                czm_translateRelativeToEye(${s}2DHigh.zxy, ${s}2DLow.zxy),\n`+`                czm_translateRelativeToEye(${s}3DHigh, ${s}3DLow),\n                czm_morphTime);\n    }\n    return p;\n}\n\n`)}return[a,o,t,r].join("\n")},$._appendShowToShader=function(e,t){if(!Object(b["a"])(e._batchTableAttributeIndices.show))return t;const n=F["a"].replaceMain(t,"czm_non_show_main"),i="void main() \n{ \n    czm_non_show_main(); \n    gl_Position *= czm_batchTable_show(batchId); \n}";return`${n}\n${i}`},$._updateColorAttribute=function(e,t,n){if(!Object(b["a"])(e._batchTableAttributeIndices.color)&&!Object(b["a"])(e._batchTableAttributeIndices.depthFailColor))return t;if(-1===t.search(/attribute\s+vec4\s+color;/g))return t;let i=t;return i=i.replace(/attribute\s+vec4\s+color;/g,""),i=n?i.replace(/(\b)color(\b)/g,"$1czm_batchTable_depthFailColor(batchId)$2"):i.replace(/(\b)color(\b)/g,"$1czm_batchTable_color(batchId)$2"),i},$._updatePickColorAttribute=function(e){let t=e.replace(/attribute\s+vec4\s+pickColor;/g,"");return t=t.replace(/(\b)pickColor(\b)/g,"$1czm_batchTable_pickColor(batchId)$2"),t},$._appendOffsetToShader=function(e,t){if(!Object(b["a"])(e._batchTableAttributeIndices.offset))return t;let n="attribute float batchId;\n";n+="attribute float applyOffset;";let i=t.replace(/attribute\s+float\s+batchId;/g,n),a="vec4 $1 = czm_computePosition();\n";return a+="    if (czm_sceneMode == czm_sceneMode3D)\n",a+="    {\n",a+="        $1 = $1 + vec4(czm_batchTable_offset(batchId) * applyOffset, 0.0);",a+="    }\n",a+="    else\n",a+="    {\n",a+="        $1 = $1 + vec4(czm_batchTable_offset2D(batchId) * applyOffset, 0.0);",a+="    }\n",i=i.replace(/vec4\s+([A-Za-z0-9_]+)\s+=\s+czm_computePosition\(\);/g,a),i},$._appendDistanceDisplayConditionToShader=function(e,t,n){if(!Object(b["a"])(e._batchTableAttributeIndices.distanceDisplayCondition))return t;const i=F["a"].replaceMain(t,"czm_non_distanceDisplayCondition_main");let a="void main() \n{ \n    czm_non_distanceDisplayCondition_main(); \n    vec2 distanceDisplayCondition = czm_batchTable_distanceDisplayCondition(batchId);\n    vec3 boundingSphereCenter3DHigh = czm_batchTable_boundingSphereCenter3DHigh(batchId);\n    vec3 boundingSphereCenter3DLow = czm_batchTable_boundingSphereCenter3DLow(batchId);\n    float boundingSphereRadius = czm_batchTable_boundingSphereRadius(batchId);\n";return a+=n?"    vec4 centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n":"    vec3 boundingSphereCenter2DHigh = czm_batchTable_boundingSphereCenter2DHigh(batchId);\n    vec3 boundingSphereCenter2DLow = czm_batchTable_boundingSphereCenter2DLow(batchId);\n    vec4 centerRTE;\n    if (czm_morphTime == 1.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow);\n    }\n    else if (czm_morphTime == 0.0)\n    {\n        centerRTE = czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy);\n    }\n    else\n    {\n        centerRTE = czm_columbusViewMorph(\n                czm_translateRelativeToEye(boundingSphereCenter2DHigh.zxy, boundingSphereCenter2DLow.zxy),\n                czm_translateRelativeToEye(boundingSphereCenter3DHigh, boundingSphereCenter3DLow),\n                czm_morphTime);\n    }\n",a+="    float radiusSq = boundingSphereRadius * boundingSphereRadius; \n    float distanceSq; \n    if (czm_sceneMode == czm_sceneMode2D) \n    { \n        distanceSq = czm_eyeHeight2D.y - radiusSq; \n    } \n    else \n    { \n        distanceSq = dot(centerRTE.xyz, centerRTE.xyz) - radiusSq; \n    } \n    distanceSq = max(distanceSq, 0.0); \n    float nearSq = distanceDisplayCondition.x * distanceDisplayCondition.x; \n    float farSq = distanceDisplayCondition.y * distanceDisplayCondition.y; \n    float show = (distanceSq >= nearSq && distanceSq <= farSq) ? 1.0 : 0.0; \n    gl_Position *= show; \n}",`${i}\n${a}`};const se=Math.max(_["a"].hardwareConcurrency-1,1);let ce;const pe=new w["a"]("combineGeometry");function he(e,t){let n,i,a,o;const r=e._instanceIds;if(e._state===V["a"].READY){n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances];const s=e._numberOfInstances=n.length,c=[];let p,h=[];for(a=0;a<s;++a)i=n[a].geometry,r.push(n[a].id),h.push({moduleName:i._workerName,geometry:i});if(!Object(b["a"])(ce))for(ce=new Array(se),a=0;a<se;a++)ce[a]=new w["a"]("createGeometry");for(h=Object(A["a"])(h,se),a=0;a<h.length;a++){let e=0;const t=h[a],n=t.length;for(o=0;o<n;++o)p=t[o],i=p.geometry,Object(b["a"])(i.constructor.pack)&&(p.offset=e,e+=Object(d["a"])(i.constructor.packedLength,i.packedLength));let r;if(e>0){const a=new Float64Array(e);for(r=[a.buffer],o=0;o<n;++o)p=t[o],i=p.geometry,Object(b["a"])(i.constructor.pack)&&(i.constructor.pack(i,a,p.offset),p.geometry=a)}c.push(ce[a].scheduleTask({subTasks:h[a]},r))}e._state=V["a"].CREATING,Promise.all(c).then((function(t){e._createGeometryResults=t,e._state=V["a"].CREATED})).catch((function(n){Me(e,t,V["a"].FAILED,n)}))}else if(e._state===V["a"].CREATED){const i=[];n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances];const a=t.scene3DOnly,o=t.mapProjection,r=pe.scheduleTask(B["a"].packCombineGeometryParameters({createGeometryResults:e._createGeometryResults,instances:n,ellipsoid:o.ellipsoid,projection:o,elementIndexUintSupported:t.context.elementIndexUint,scene3DOnly:a,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e._createPickOffsets},i),i);e._createGeometryResults=void 0,e._state=V["a"].COMBINING,Promise.resolve(r).then((function(n){const i=B["a"].unpackCombineGeometryResults(n);e._geometries=i.geometries,e._attributeLocations=i.attributeLocations,e.modelMatrix=C["a"].clone(i.modelMatrix,e.modelMatrix),e._pickOffsets=i.pickOffsets,e._offsetInstanceExtend=i.offsetInstanceExtend,e._instanceBoundingSpheres=i.boundingSpheres,e._instanceBoundingSpheresCV=i.boundingSpheresCV,Object(b["a"])(e._geometries)&&e._geometries.length>0?(e._recomputeBoundingSpheres=!0,e._state=V["a"].COMBINED):Me(e,t,V["a"].FAILED,void 0)})).catch((function(n){Me(e,t,V["a"].FAILED,n)}))}}function ue(e,t){const n=Array.isArray(e.geometryInstances)?e.geometryInstances:[e.geometryInstances],i=e._numberOfInstances=n.length,a=new Array(i),o=e._instanceIds;let r,s,c=0;for(s=0;s<i;s++){r=n[s];const e=r.geometry;let t;t=Object(b["a"])(e.attributes)&&Object(b["a"])(e.primitiveType)?X(e):e.constructor.createGeometry(e),a[c++]=Z(r,t),o.push(r.id)}a.length=c;const p=t.scene3DOnly,h=t.mapProjection,u=B["a"].combineGeometry({instances:a,ellipsoid:h.ellipsoid,projection:h,elementIndexUintSupported:t.context.elementIndexUint,scene3DOnly:p,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e._createPickOffsets});e._geometries=u.geometries,e._attributeLocations=u.attributeLocations,e.modelMatrix=C["a"].clone(u.modelMatrix,e.modelMatrix),e._pickOffsets=u.pickOffsets,e._offsetInstanceExtend=u.offsetInstanceExtend,e._instanceBoundingSpheres=u.boundingSpheres,e._instanceBoundingSpheresCV=u.boundingSpheresCV,Object(b["a"])(e._geometries)&&e._geometries.length>0?(e._recomputeBoundingSpheres=!0,e._state=V["a"].COMBINED):Me(e,t,V["a"].FAILED,void 0)}function de(e,t){const n=e._batchTableAttributeIndices.offset;if(!e._recomputeBoundingSpheres||!Object(b["a"])(n))return void(e._recomputeBoundingSpheres=!1);let a;const r=e._offsetInstanceExtend,s=e._instanceBoundingSpheres,c=s.length;let p=e._tempBoundingSpheres;if(!Object(b["a"])(p)){for(p=new Array(c),a=0;a<c;a++)p[a]=new i["a"];e._tempBoundingSpheres=p}for(a=0;a<c;++a){let t=p[a];const i=e._batchTable.getBatchedAttribute(a,n,new o["a"]);t=s[a].clone(t),Pe(t,i,r[a])}const h=[],u=[],d=[];for(a=0;a<c;++a){const e=p[a],t=e.center.x-e.radius;t>0||i["a"].intersectPlane(e,T["a"].ORIGIN_ZX_PLANE)!==v["a"].INTERSECTING?h.push(e):(u.push(e),d.push(e))}let l=h[0],m=d[0],f=u[0];for(a=1;a<h.length;a++)l=i["a"].union(l,h[a]);for(a=1;a<d.length;a++)m=i["a"].union(m,d[a]);for(a=1;a<u.length;a++)f=i["a"].union(f,u[a]);const _=[];for(Object(b["a"])(l)&&_.push(l),Object(b["a"])(m)&&_.push(m),Object(b["a"])(f)&&_.push(f),a=0;a<_.length;a++){const n=_[a].clone(e._boundingSpheres[a]);e._boundingSpheres[a]=n,e._boundingSphereCV[a]=i["a"].projectTo2D(n,t.mapProjection,e._boundingSphereCV[a])}$._updateBoundingVolumes(e,t,e.modelMatrix,!0),e._recomputeBoundingSpheres=!1}const le=new f["a"],be=new s["a"],me=new o["a"],fe=new i["a"];function _e(e,t){const n=Object(b["a"])(e._batchTableAttributeIndices.distanceDisplayCondition);if(!n||e._batchTableBoundingSpheresUpdated)return;const a=e._batchTableBoundingSphereAttributeIndices,o=a.center3DHigh,r=a.center3DLow,s=a.center2DHigh,c=a.center2DLow,p=a.radius,h=t.mapProjection,u=h.ellipsoid,d=e._batchTable,l=e._instanceBoundingSpheres,m=l.length;for(let _=0;_<m;++_){let n=l[_];if(!Object(b["a"])(n))continue;const a=e.modelMatrix;Object(b["a"])(a)&&(n=i["a"].transform(n,a,fe));const m=n.center,g=n.radius;let y=f["a"].fromCartesian(m,le);if(d.setBatchedAttribute(_,o,y.high),d.setBatchedAttribute(_,r,y.low),!t.scene3DOnly){const e=u.cartesianToCartographic(m,be),t=h.project(e,me);y=f["a"].fromCartesian(t,le),d.setBatchedAttribute(_,s,y.high),d.setBatchedAttribute(_,c,y.low)}d.setBatchedAttribute(_,p,g)}e._batchTableBoundingSpheresUpdated=!0}const ge=new o["a"],ye=new o["a"];function Oe(e,t){const n=Object(b["a"])(e._batchTableAttributeIndices.offset);if(!n||e._batchTableOffsetsUpdated||t.scene3DOnly)return;const a=e._batchTableOffsetAttribute2DIndex,r=t.mapProjection,s=r.ellipsoid,c=e._batchTable,p=e._instanceBoundingSpheres,h=p.length;for(let u=0;u<h;++u){let t=p[u];if(!Object(b["a"])(t))continue;const n=c.getBatchedAttribute(u,e._batchTableAttributeIndices.offset);if(o["a"].equals(n,o["a"].ZERO)){c.setBatchedAttribute(u,a,o["a"].ZERO);continue}const h=e.modelMatrix;Object(b["a"])(h)&&(t=i["a"].transform(t,h,fe));let d=t.center;d=s.scaleToGeodeticSurface(d,ye);let l=s.cartesianToCartographic(d,be);const m=r.project(l,me),f=o["a"].add(n,d,ge);l=s.cartesianToCartographic(f,l);const _=r.project(l,ge),g=o["a"].subtract(_,m,ge),y=g.x;g.x=g.z,g.z=g.y,g.y=y,c.setBatchedAttribute(u,a,g)}e._batchTableOffsetsUpdated=!0}function Se(e,t){const n=e._attributeLocations,a=e._geometries,o=t.scene3DOnly,r=t.context,s=[],c=a.length;for(let p=0;p<c;++p){const c=a[p];if(s.push(E["a"].fromGeometry({context:r,geometry:c,attributeLocations:n,bufferUsage:j["a"].STATIC_DRAW,interleave:e._interleave})),Object(b["a"])(e._createBoundingVolumeFunction))e._createBoundingVolumeFunction(t,c);else if(e._boundingSpheres.push(i["a"].clone(c.boundingSphere)),e._boundingSphereWC.push(new i["a"]),!o){const t=c.boundingSphereCV.center,n=t.x,a=t.y,o=t.z;t.x=o,t.y=n,t.z=a,e._boundingSphereCV.push(i["a"].clone(c.boundingSphereCV)),e._boundingSphere2D.push(new i["a"]),e._boundingSphereMorph.push(new i["a"])}}e._va=s,e._primitiveType=a[0].primitiveType,e.releaseGeometryInstances&&(e.geometryInstances=void 0),e._geometries=void 0,Me(e,t,V["a"].COMPLETE,void 0)}function ve(e,t,n,i){let a,o=n.getRenderState();i?(a=Object(c["a"])(o,!1),a.cull={enabled:!0,face:M["a"].BACK},e._frontFaceRS=k["a"].fromCache(a),a.cull.face=M["a"].FRONT,e._backFaceRS=k["a"].fromCache(a)):(e._frontFaceRS=k["a"].fromCache(o),e._backFaceRS=e._frontFaceRS),a=Object(c["a"])(o,!1),Object(b["a"])(e._depthFailAppearance)&&(a.depthTest.enabled=!1),Object(b["a"])(e._depthFailAppearance)&&(o=e._depthFailAppearance.getRenderState(),a=Object(c["a"])(o,!1),a.depthTest.func=R["a"].GREATER,i?(a.cull={enabled:!0,face:M["a"].BACK},e._frontFaceDepthFailRS=k["a"].fromCache(a),a.cull.face=M["a"].FRONT,e._backFaceDepthFailRS=k["a"].fromCache(a)):(e._frontFaceDepthFailRS=k["a"].fromCache(a),e._backFaceDepthFailRS=e._frontFaceRS))}function Ce(e,t,n){const i=t.context,a=e._attributeLocations;let o=e._batchTable.getVertexShaderCallback()(n.vertexShaderSource);o=$._appendOffsetToShader(e,o),o=$._appendShowToShader(e,o),o=$._appendDistanceDisplayConditionToShader(e,o,t.scene3DOnly),o=ee(o),o=$._updateColorAttribute(e,o,!1),o=ne(e,o),o=$._modifyShaderPosition(e,o,t.scene3DOnly);let r=n.getFragmentShaderSource();r=te(r),e._sp=z["a"].replaceCache({context:i,shaderProgram:e._sp,vertexShaderSource:o,fragmentShaderSource:r,attributeLocations:a}),oe(e._sp,a),Object(b["a"])(e._depthFailAppearance)&&(o=e._batchTable.getVertexShaderCallback()(e._depthFailAppearance.vertexShaderSource),o=$._appendShowToShader(e,o),o=$._appendDistanceDisplayConditionToShader(e,o,t.scene3DOnly),o=ee(o),o=$._updateColorAttribute(e,o,!0),o=ne(e,o),o=$._modifyShaderPosition(e,o,t.scene3DOnly),o=ie(o),r=e._depthFailAppearance.getFragmentShaderSource(),r=te(r),r=ae(r),e._spDepthFail=z["a"].replaceCache({context:i,shaderProgram:e._spDepthFail,vertexShaderSource:o,fragmentShaderSource:r,attributeLocations:a}),oe(e._spDepthFail,a))}const Te=new C["a"],De=new o["a"];function Ae(e,t,n,i){const a=Object(b["a"])(n)?n._uniforms:void 0,o={},r=t.uniforms;if(Object(b["a"])(r))for(const c in r)r.hasOwnProperty(c)&&(o[c]=re(r,c));let s=Object(h["a"])(o,a);return s=e._batchTable.getUniformMapCallback()(s),Object(b["a"])(e.rtcCenter)&&(s.u_modifiedModelView=function(){const t=i.context.uniformState.view;return C["a"].multiply(t,e._modelMatrix,Te),C["a"].multiplyByPoint(Te,e.rtcCenter,De),C["a"].setTranslation(Te,De,Te),Te}),s}function we(e,t,n,i,a,o,r,s){const c=Ae(e,t,n,s);let p;Object(b["a"])(e._depthFailAppearance)&&(p=Ae(e,e._depthFailAppearance,e._depthFailAppearance.material,s));const h=i?P["a"].TRANSLUCENT:P["a"].OPAQUE;let u=a?2:1;u*=Object(b["a"])(e._depthFailAppearance)?2:1,o.length=e._va.length*u;const d=o.length;let l=0;for(let m=0;m<d;++m){let t;a&&(t=o[m],Object(b["a"])(t)||(t=o[m]=new I["a"]({owner:e,primitiveType:e._primitiveType})),t.vertexArray=e._va[l],t.renderState=e._backFaceRS,t.shaderProgram=e._sp,t.uniformMap=c,t.pass=h,++m),t=o[m],Object(b["a"])(t)||(t=o[m]=new I["a"]({owner:e,primitiveType:e._primitiveType})),t.vertexArray=e._va[l],t.renderState=e._frontFaceRS,t.shaderProgram=e._sp,t.uniformMap=c,t.pass=h,Object(b["a"])(e._depthFailAppearance)&&(a&&(++m,t=o[m],Object(b["a"])(t)||(t=o[m]=new I["a"]({owner:e,primitiveType:e._primitiveType})),t.vertexArray=e._va[l],t.renderState=e._backFaceDepthFailRS,t.shaderProgram=e._spDepthFail,t.uniformMap=p,t.pass=h),++m,t=o[m],Object(b["a"])(t)||(t=o[m]=new I["a"]({owner:e,primitiveType:e._primitiveType})),t.vertexArray=e._va[l],t.renderState=e._frontFaceDepthFailRS,t.shaderProgram=e._spDepthFail,t.uniformMap=p,t.pass=h),++l}}function je(e,t,n,i,a,o,r,s){let c;$._updateBoundingVolumes(e,t,a),t.mode===G["a"].SCENE3D?c=e._boundingSphereWC:t.mode===G["a"].COLUMBUS_VIEW?c=e._boundingSphereCV:t.mode===G["a"].SCENE2D&&Object(b["a"])(e._boundingSphere2D)?c=e._boundingSphere2D:Object(b["a"])(e._boundingSphereMorph)&&(c=e._boundingSphereMorph);const p=t.commandList,h=t.passes;if(h.render||h.pick){const t=e.allowPicking,i=H["a"].castShadows(e.shadows),h=H["a"].receiveShadows(e.shadows),u=n.length;let d=s?2:1;d*=Object(b["a"])(e._depthFailAppearance)?2:1;for(let e=0;e<u;++e){const s=Math.floor(e/d),u=n[e];u.modelMatrix=a,u.boundingVolume=c[s],u.cull=o,u.debugShowBoundingVolume=r,u.castShadows=i,u.receiveShadows=h,u.pickId=t?"v_pickColor":void 0,p.push(u)}}}$._updateBoundingVolumes=function(e,t,n,a){let o,r,s;if(a||!C["a"].equals(n,e._modelMatrix))for(C["a"].clone(n,e._modelMatrix),r=e._boundingSpheres.length,o=0;o<r;++o)s=e._boundingSpheres[o],Object(b["a"])(s)&&(e._boundingSphereWC[o]=i["a"].transform(s,n,e._boundingSphereWC[o]),t.scene3DOnly||(e._boundingSphere2D[o]=i["a"].clone(e._boundingSphereCV[o],e._boundingSphere2D[o]),e._boundingSphere2D[o].center.x=0,e._boundingSphereMorph[o]=i["a"].union(e._boundingSphereWC[o],e._boundingSphereCV[o])));const c=e.appearance.pixelSize;if(Object(b["a"])(c))for(r=e._boundingSpheres.length,o=0;o<r;++o){s=e._boundingSpheres[o];const n=e._boundingSphereWC[o],i=t.camera.getPixelSize(s,t.context.drawingBufferWidth,t.context.drawingBufferHeight),a=i*c;n.radius=s.radius+a}},$.prototype.update=function(e){if(!Object(b["a"])(this.geometryInstances)&&0===this._va.length||Object(b["a"])(this.geometryInstances)&&Array.isArray(this.geometryInstances)&&0===this.geometryInstances.length||!Object(b["a"])(this.appearance)||e.mode!==G["a"].SCENE3D&&e.scene3DOnly||!e.passes.render&&!e.passes.pick)return;if(Object(b["a"])(this._error))throw this._error;if(this._state===V["a"].FAILED)return;const t=e.context;if(Object(b["a"])(this._batchTable)||J(this,t),this._batchTable.attributes.length>0){if(0===x["a"].maximumVertexTextureImageUnits)throw new D["a"]("Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.");this._batchTable.update(e)}if(this._state!==V["a"].COMPLETE&&this._state!==V["a"].COMBINED&&(this.asynchronous?he(this,e):ue(this,e)),this._state===V["a"].COMBINED&&(_e(this,e),Oe(this,e),Se(this,e)),!this.show||this._state!==V["a"].COMPLETE)return;this._batchTableOffsetsUpdated||Oe(this,e),this._recomputeBoundingSpheres&&de(this,e);const n=this.appearance,i=n.material;let a=!1,o=!1;this._appearance!==n?(this._appearance=n,this._material=i,a=!0,o=!0):this._material!==i&&(this._material=i,o=!0);const r=this.depthFailAppearance,s=Object(b["a"])(r)?r.material:void 0;this._depthFailAppearance!==r?(this._depthFailAppearance=r,this._depthFailMaterial=s,a=!0,o=!0):this._depthFailMaterial!==s&&(this._depthFailMaterial=s,o=!0);const c=this._appearance.isTranslucent();this._translucent!==c&&(this._translucent=c,a=!0),Object(b["a"])(this._material)&&this._material.update(t);const p=n.closed&&c;if(a){const e=Object(d["a"])(this._createRenderStatesFunction,ve);e(this,t,n,p)}if(o){const t=Object(d["a"])(this._createShaderProgramFunction,Ce);t(this,e,n)}if(a||o){const t=Object(d["a"])(this._createCommandsFunction,we);t(this,n,i,c,p,this._colorCommands,this._pickCommands,e)}const h=Object(d["a"])(this._updateAndQueueCommandsFunction,je);h(this,e,this._colorCommands,this._pickCommands,this.modelMatrix,this.cull,this.debugShowBoundingVolume,p)};const xe=new i["a"],Ie=new i["a"];function Pe(e,t,n){if(n===S["a"].TOP){const n=i["a"].clone(e,xe),a=i["a"].clone(e,Ie);a.center=o["a"].add(a.center,t,a.center),e=i["a"].union(n,a,e)}else n===S["a"].ALL&&(e.center=o["a"].add(e.center,t,e.center));return e}function ke(e,t,n){return function(){const i=e.getBatchedAttribute(t,n),a=e.attributes[n],o=a.componentsPerAttribute,r=u["a"].createTypedArray(a.componentDatatype,o);return Object(b["a"])(i.constructor.pack)?i.constructor.pack(i,r,0):r[0]=i,r}}function ze(e,t,n,i,a){return function(o){const r=Y(o);e.setBatchedAttribute(t,n,r),"offset"===a&&(i._recomputeBoundingSpheres=!0,i._batchTableOffsetsUpdated=!1)}}const Fe=new o["a"];function Ee(e,t,n){t.boundingSphere={get:function(){let a=e._instanceBoundingSpheres[n];if(Object(b["a"])(a)){a=a.clone();const r=e.modelMatrix,s=t.offset;Object(b["a"])(s)&&Pe(a,o["a"].fromArray(s.get(),0,Fe),e._offsetInstanceExtend[n]),Object(b["a"])(r)&&(a=i["a"].transform(a,r))}return a}},t.boundingSphereCV={get:function(){return e._instanceBoundingSpheresCV[n]}}}function Le(e,t,n){t.pickId={get:function(){return e._pickIds[n]}}}function Me(e,t,n,i){e._error=i,e._state=n,t.afterRender.push((function(){e._ready=e._state===V["a"].COMPLETE||e._state===V["a"].FAILED,Object(b["a"])(i)?e._readyPromise.reject(i):e._readyPromise.resolve(e)}))}$.prototype.getGeometryInstanceAttributes=function(e){let t=-1;const n=this._lastPerInstanceAttributeIndex,i=this._instanceIds,a=i.length;for(let p=0;p<a;++p){const o=(n+p)%a;if(e===i[o]){t=o;break}}if(-1===t)return;let o=this._perInstanceAttributeCache[t];if(Object(b["a"])(o))return o;const r=this._batchTable,s=this._batchTableAttributeIndices;o={};const c={};for(const p in s)if(s.hasOwnProperty(p)){const e=s[p];c[p]={get:ke(r,t,e),set:ze(r,t,e,this,p)}}return Ee(this,c,t),Le(this,c,t),Object.defineProperties(o,c),this._lastPerInstanceAttributeIndex=t,this._perInstanceAttributeCache[t]=o,o},$.prototype.isDestroyed=function(){return!1},$.prototype.destroy=function(){let e,t;this._sp=this._sp&&this._sp.destroy(),this._spDepthFail=this._spDepthFail&&this._spDepthFail.destroy();const n=this._va;for(e=n.length,t=0;t<e;++t)n[t].destroy();this._va=void 0;const i=this._pickIds;for(e=i.length,t=0;t<e;++t)i[t].destroy();return this._pickIds=void 0,this._batchTable=this._batchTable&&this._batchTable.destroy(),this._instanceIds=void 0,this._perInstanceAttributeCache=void 0,this._attributeLocations=void 0,Object(m["a"])(this)},t["a"]=$}}]);