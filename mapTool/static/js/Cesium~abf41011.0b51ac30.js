(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~abf41011"],{1757:function(e,t,a){"use strict";var n=a("2f63");function o(e,t){this.positions=Object(n["a"])(e)?e:[],this.holes=Object(n["a"])(t)?t:[]}t["a"]=o},"188e":function(e,t,a){"use strict";var n=a("be18"),o=a("a561"),r=a("2f63"),i=a("52f0");function c(e,t){this.normal=n["a"].clone(e),this.distance=t}c.fromPointNormal=function(e,t,a){const o=-n["a"].dot(t,e);return Object(r["a"])(a)?(n["a"].clone(t,a.normal),a.distance=o,a):new c(t,o)};const s=new n["a"];c.fromCartesian4=function(e,t){const a=n["a"].fromCartesian4(e,s),o=e.w;return Object(r["a"])(t)?(n["a"].clone(a,t.normal),t.distance=o,t):new c(a,o)},c.getPointDistance=function(e,t){return n["a"].dot(e.normal,t)+e.distance};const l=new n["a"];c.projectPointOntoPlane=function(e,t,a){Object(r["a"])(a)||(a=new n["a"]);const o=c.getPointDistance(e,t),i=n["a"].multiplyByScalar(e.normal,o,l);return n["a"].subtract(t,i,a)};const u=new i["a"],p=new o["a"],h=new n["a"];c.transform=function(e,t,a){const r=e.normal,s=e.distance,l=i["a"].inverseTranspose(t,u);let g=o["a"].fromElements(r.x,r.y,r.z,s,p);g=i["a"].multiplyByVector(l,g,g);const d=n["a"].fromCartesian4(g,h);return g=o["a"].divideByScalar(g,n["a"].magnitude(d),g),c.fromCartesian4(g,a)},c.clone=function(e,t){return Object(r["a"])(t)?(n["a"].clone(e.normal,t.normal),t.distance=e.distance,t):new c(e.normal,e.distance)},c.equals=function(e,t){return e.distance===t.distance&&n["a"].equals(e.normal,t.normal)},c.ORIGIN_XY_PLANE=Object.freeze(new c(n["a"].UNIT_Z,0)),c.ORIGIN_YZ_PLANE=Object.freeze(new c(n["a"].UNIT_X,0)),c.ORIGIN_ZX_PLANE=Object.freeze(new c(n["a"].UNIT_Y,0)),t["a"]=c},"1b8d":function(e,t,a){"use strict";var n=a("daa2");const o={POINTS:n["a"].POINTS,LINES:n["a"].LINES,LINE_LOOP:n["a"].LINE_LOOP,LINE_STRIP:n["a"].LINE_STRIP,TRIANGLES:n["a"].TRIANGLES,TRIANGLE_STRIP:n["a"].TRIANGLE_STRIP,TRIANGLE_FAN:n["a"].TRIANGLE_FAN,isLines:function(e){return e===o.LINES||e===o.LINE_LOOP||e===o.LINE_STRIP},isTriangles:function(e){return e===o.TRIANGLES||e===o.TRIANGLE_STRIP||e===o.TRIANGLE_FAN},validate:function(e){return e===o.POINTS||e===o.LINES||e===o.LINE_LOOP||e===o.LINE_STRIP||e===o.TRIANGLES||e===o.TRIANGLE_STRIP||e===o.TRIANGLE_FAN}};t["a"]=Object.freeze(o)},2105:function(e,t,a){"use strict";var n=a("cef5"),o=a("be18"),r=a("abab"),i=a("535a"),c=a("2f63"),s=a("d2c7"),l=a("81d7"),u=a("473c"),p=a("1b8d"),h=a("0541");function g(e){e=Object(i["a"])(e,i["a"].EMPTY_OBJECT);const t=Object(i["a"])(e.vertexFormat,h["a"].DEFAULT);this._vertexFormat=t,this._workerName="createPlaneGeometry"}g.packedLength=h["a"].packedLength,g.pack=function(e,t,a){return a=Object(i["a"])(a,0),h["a"].pack(e._vertexFormat,t,a),t};const d=new h["a"],f={vertexFormat:d};g.unpack=function(e,t,a){t=Object(i["a"])(t,0);const n=h["a"].unpack(e,t,d);return Object(c["a"])(a)?(a._vertexFormat=h["a"].clone(n,a._vertexFormat),a):new g(f)};const m=new o["a"](-.5,-.5,0),y=new o["a"](.5,.5,0);g.createGeometry=function(e){const t=e._vertexFormat,a=new u["a"];let i,c;if(t.position){if(c=new Float64Array(12),c[0]=m.x,c[1]=m.y,c[2]=0,c[3]=y.x,c[4]=m.y,c[5]=0,c[6]=y.x,c[7]=y.y,c[8]=0,c[9]=m.x,c[10]=y.y,c[11]=0,a.position=new l["a"]({componentDatatype:r["a"].DOUBLE,componentsPerAttribute:3,values:c}),t.normal){const e=new Float32Array(12);e[0]=0,e[1]=0,e[2]=1,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=1,e[9]=0,e[10]=0,e[11]=1,a.normal=new l["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:e})}if(t.st){const e=new Float32Array(8);e[0]=0,e[1]=0,e[2]=1,e[3]=0,e[4]=1,e[5]=1,e[6]=0,e[7]=1,a.st=new l["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:2,values:e})}if(t.tangent){const e=new Float32Array(12);e[0]=1,e[1]=0,e[2]=0,e[3]=1,e[4]=0,e[5]=0,e[6]=1,e[7]=0,e[8]=0,e[9]=1,e[10]=0,e[11]=0,a.tangent=new l["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:e})}if(t.bitangent){const e=new Float32Array(12);e[0]=0,e[1]=1,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=1,e[8]=0,e[9]=0,e[10]=1,e[11]=0,a.bitangent=new l["a"]({componentDatatype:r["a"].FLOAT,componentsPerAttribute:3,values:e})}i=new Uint16Array(6),i[0]=0,i[1]=1,i[2]=2,i[3]=0,i[4]=2,i[5]=3}return new s["a"]({attributes:a,indices:i,primitiveType:p["a"].TRIANGLES,boundingSphere:new n["a"](o["a"].ZERO,Math.sqrt(2))})},t["a"]=g},"24e4":function(e,t,a){"use strict";var n=a("9201"),o=a("ee1e"),r=a("670c"),i=a("be18"),c=a("bef8"),s=a("abab"),l=a("535a"),u=a("2f63"),p=a("c52f"),h=a("cef8"),g=a("d2c7"),d=a("81d7"),f=a("473c"),m=a("c1e2"),y=a("0123"),_=a("93da"),b=a("df07"),T=a("9251"),E=a("1b8d"),A=a("0260"),P=a("9410"),w=a("b48e");const O={computeHierarchyPackedLength:function(e){let t=0;const a=[e];while(a.length>0){const e=a.pop();if(!Object(u["a"])(e))continue;t+=2;const n=e.positions,o=e.holes;if(Object(u["a"])(n)&&(t+=n.length*i["a"].packedLength),Object(u["a"])(o)){const e=o.length;for(let t=0;t<e;++t)a.push(o[t])}}return t},packPolygonHierarchy:function(e,t,a){const n=[e];while(n.length>0){const e=n.pop();if(!Object(u["a"])(e))continue;const o=e.positions,r=e.holes;if(t[a++]=Object(u["a"])(o)?o.length:0,t[a++]=Object(u["a"])(r)?r.length:0,Object(u["a"])(o)){const e=o.length;for(let n=0;n<e;++n,a+=3)i["a"].pack(o[n],t,a)}if(Object(u["a"])(r)){const e=r.length;for(let t=0;t<e;++t)n.push(r[t])}}return a},unpackPolygonHierarchy:function(e,t){const a=e[t++],n=e[t++],o=new Array(a),r=n>0?new Array(n):void 0;for(let c=0;c<a;++c,t+=i["a"].packedLength)o[c]=i["a"].unpack(e,t);for(let i=0;i<n;++i)r[i]=O.unpackPolygonHierarchy(e,t),t=r[i].startingIndex,delete r[i].startingIndex;return{positions:o,holes:r,startingIndex:t}}},R=new i["a"];function L(e,t,a,n){return i["a"].subtract(t,e,R),i["a"].multiplyByScalar(R,a/n,R),i["a"].add(e,R,R),[R.x,R.y,R.z]}O.subdivideLineCount=function(e,t,a){const n=i["a"].distance(e,t),o=n/a,r=Math.max(0,Math.ceil(_["a"].log2(o)));return Math.pow(2,r)};const I=new c["a"],B=new c["a"],G=new c["a"],S=new i["a"];O.subdivideRhumbLineCount=function(e,t,a,n){const o=e.cartesianToCartographic(t,I),r=e.cartesianToCartographic(a,B),i=new h["a"](o,r,e),c=i.surfaceDistance/n,s=Math.max(0,Math.ceil(_["a"].log2(c)));return Math.pow(2,s)},O.subdivideLine=function(e,t,a,n){const o=O.subdivideLineCount(e,t,a),r=i["a"].distance(e,t),c=r/o;Object(u["a"])(n)||(n=[]);const s=n;s.length=3*o;let l=0;for(let i=0;i<o;i++){const a=L(e,t,i*c,r);s[l++]=a[0],s[l++]=a[1],s[l++]=a[2]}return s},O.subdivideRhumbLine=function(e,t,a,n,o){const r=e.cartesianToCartographic(t,I),i=e.cartesianToCartographic(a,B),c=new h["a"](r,i,e),s=c.surfaceDistance/n,l=Math.max(0,Math.ceil(_["a"].log2(s))),p=Math.pow(2,l),g=c.surfaceDistance/p;Object(u["a"])(o)||(o=[]);const d=o;d.length=3*p;let f=0;for(let u=0;u<p;u++){const t=c.interpolateUsingSurfaceDistance(u*g,G),a=e.cartographicToCartesian(t,S);d[f++]=a.x,d[f++]=a.y,d[f++]=a.z}return d};const v=new i["a"],N=new i["a"],C=new i["a"],D=new i["a"];O.scaleToGeodeticHeightExtruded=function(e,t,a,n,o){n=Object(l["a"])(n,p["a"].WGS84);const r=v;let c=N;const s=C;let h=D;if(Object(u["a"])(e)&&Object(u["a"])(e.attributes)&&Object(u["a"])(e.attributes.position)){const l=e.attributes.position.values,u=l.length/2;for(let e=0;e<u;e+=3)i["a"].fromArray(l,e,s),n.geodeticSurfaceNormal(s,r),h=n.scaleToGeodeticSurface(s,h),c=i["a"].multiplyByScalar(r,a,c),c=i["a"].add(h,c,c),l[e+u]=c.x,l[e+1+u]=c.y,l[e+2+u]=c.z,o&&(h=i["a"].clone(s,h)),c=i["a"].multiplyByScalar(r,t,c),c=i["a"].add(h,c,c),l[e]=c.x,l[e+1]=c.y,l[e+2]=c.z}return e},O.polygonOutlinesFromHierarchy=function(e,t,a){const n=[],r=new P["a"];let c,s,l;r.enqueue(e);while(0!==r.length){const e=r.dequeue();let p=e.positions;if(t)for(l=p.length,c=0;c<l;c++)a.scaleToGeodeticSurface(p[c],p[c]);if(p=Object(o["a"])(p,i["a"].equalsEpsilon,!0),p.length<3)continue;const h=e.holes?e.holes.length:0;for(c=0;c<h;c++){const p=e.holes[c];let h=p.positions;if(t)for(l=h.length,s=0;s<l;++s)a.scaleToGeodeticSurface(h[s],h[s]);if(h=Object(o["a"])(h,i["a"].equalsEpsilon,!0),h.length<3)continue;n.push(h);let g=0;for(Object(u["a"])(p.holes)&&(g=p.holes.length),s=0;s<g;s++)r.enqueue(p.holes[s])}n.push(p)}return n},O.polygonsFromHierarchy=function(e,t,a,n){const r=[],c=[],s=new P["a"];s.enqueue(e);while(0!==s.length){const e=s.dequeue();let l=e.positions;const p=e.holes;let h,g;if(a)for(g=l.length,h=0;h<g;h++)n.scaleToGeodeticSurface(l[h],l[h]);if(l=Object(o["a"])(l,i["a"].equalsEpsilon,!0),l.length<3)continue;let d=t(l);if(!Object(u["a"])(d))continue;const f=[];let m=T["a"].computeWindingOrder2D(d);m===w["a"].CLOCKWISE&&(d.reverse(),l=l.slice().reverse());let y=l.slice();const _=Object(u["a"])(p)?p.length:0,b=[];let E;for(h=0;h<_;h++){const e=p[h];let r=e.positions;if(a)for(g=r.length,E=0;E<g;++E)n.scaleToGeodeticSurface(r[E],r[E]);if(r=Object(o["a"])(r,i["a"].equalsEpsilon,!0),r.length<3)continue;const c=t(r);if(!Object(u["a"])(c))continue;m=T["a"].computeWindingOrder2D(c),m===w["a"].CLOCKWISE&&(c.reverse(),r=r.slice().reverse()),b.push(r),f.push(y.length),y=y.concat(r),d=d.concat(c);let l=0;for(Object(u["a"])(e.holes)&&(l=e.holes.length),E=0;E<l;E++)s.enqueue(e.holes[E])}r.push({outerRing:l,holes:b}),c.push({positions:y,positions2D:d,holes:f})}return{hierarchy:r,polygons:c}};const x=new r["a"],j=new i["a"],k=new A["a"],F=new b["a"];O.computeBoundingRectangle=function(e,t,a,n,o){const r=A["a"].fromAxisAngle(e,n,k),c=b["a"].fromQuaternion(r,F);let s=Number.POSITIVE_INFINITY,l=Number.NEGATIVE_INFINITY,p=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY;const g=a.length;for(let d=0;d<g;++d){const e=i["a"].clone(a[d],j);b["a"].multiplyByVector(c,e,e);const n=t(e,x);Object(u["a"])(n)&&(s=Math.min(s,n.x),l=Math.max(l,n.x),p=Math.min(p,n.y),h=Math.max(h,n.y))}return o.x=s,o.y=p,o.width=l-s,o.height=h-p,o},O.createGeometryFromPositions=function(e,t,a,o,r,i){let c=T["a"].triangulate(t.positions2D,t.holes);c.length<3&&(c=[0,1,2]);const l=t.positions;if(o){const e=l.length,t=new Array(3*e);let a=0;for(let o=0;o<e;o++){const e=l[o];t[a++]=e.x,t[a++]=e.y,t[a++]=e.z}const n=new g["a"]({attributes:{position:new d["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:t})},indices:c,primitiveType:E["a"].TRIANGLES});return r.normal?m["a"].computeNormal(n):n}return i===n["a"].GEODESIC?T["a"].computeSubdivision(e,l,c,a):i===n["a"].RHUMB?T["a"].computeRhumbLineSubdivision(e,l,c,a):void 0};const H=[],M=new i["a"],V=new i["a"];O.computeWallGeometry=function(e,t,a,o,r){let c,l,u,p,h,m=e.length,b=0;if(o)for(l=3*m*2,c=new Array(2*l),u=0;u<m;u++)p=e[u],h=e[(u+1)%m],c[b]=c[b+l]=p.x,++b,c[b]=c[b+l]=p.y,++b,c[b]=c[b+l]=p.z,++b,c[b]=c[b+l]=h.x,++b,c[b]=c[b+l]=h.y,++b,c[b]=c[b+l]=h.z,++b;else{const o=_["a"].chordLength(a,t.maximumRadius);let i=0;if(r===n["a"].GEODESIC)for(u=0;u<m;u++)i+=O.subdivideLineCount(e[u],e[(u+1)%m],o);else if(r===n["a"].RHUMB)for(u=0;u<m;u++)i+=O.subdivideRhumbLineCount(t,e[u],e[(u+1)%m],o);for(l=3*(i+m),c=new Array(2*l),u=0;u<m;u++){let a;p=e[u],h=e[(u+1)%m],r===n["a"].GEODESIC?a=O.subdivideLine(p,h,o,H):r===n["a"].RHUMB&&(a=O.subdivideRhumbLine(t,p,h,o,H));const i=a.length;for(let e=0;e<i;++e,++b)c[b]=a[e],c[b+l]=a[e];c[b]=h.x,c[b+l]=h.x,++b,c[b]=h.y,c[b+l]=h.y,++b,c[b]=h.z,c[b+l]=h.z,++b}}m=c.length;const T=y["a"].createTypedArray(m/3,m-6*e.length);let A=0;for(m/=6,u=0;u<m;u++){const e=u,t=e+1,a=e+m,n=a+1;p=i["a"].fromArray(c,3*e,M),h=i["a"].fromArray(c,3*t,V),i["a"].equalsEpsilon(p,h,_["a"].EPSILON10,_["a"].EPSILON10)||(T[A++]=e,T[A++]=a,T[A++]=t,T[A++]=t,T[A++]=a,T[A++]=n)}return new g["a"]({attributes:new f["a"]({position:new d["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:c})}),indices:T,primitiveType:E["a"].TRIANGLES})},t["a"]=O},"29bd":function(e,t,a){"use strict";var n=a("670c"),o=a("be18"),r=a("a561"),i=a("bef8"),c=a("d0c2"),s=a("a3bd"),l=a("93da"),u=a("df07"),p=a("52f0"),h=a("31af"),g=a("0260"),d=a("f806"),f=a("b639");const m=[new o["a"],new o["a"]],y=new o["a"],_=new o["a"],b=new o["a"],T=new o["a"],E=new o["a"],A=new o["a"],P=new o["a"],w=new o["a"],O=new o["a"],R=new o["a"],L=new o["a"],I={};let B=new i["a"];function G(e,t){const a=new Array(e.length);for(let n=0;n<e.length;n++){const o=e[n];B=t.cartesianToCartographic(o,B),a[n]=B.height,e[n]=t.scaleToGeodeticSurface(o,o)}return a}function S(e,t,a,n){const r=e[0],i=e[1],c=o["a"].angleBetween(r,i),s=Math.ceil(c/n),l=new Array(s);let u;if(t===a){for(u=0;u<s;u++)l[u]=t;return l.push(a),l}const p=a-t,h=p/s;for(u=1;u<s;u++){const e=t+u*h;l[u]=e}return l[0]=t,l.push(a),l}const v=new o["a"],N=new o["a"];function C(e,t,a,r){const i=new s["a"](a,r),c=i.projectPointOntoPlane(o["a"].add(a,e,v),v),l=i.projectPointOntoPlane(o["a"].add(a,t,N),N),u=n["a"].angleBetween(c,l);return l.x*c.y-l.y*c.x>=0?-u:u}const D=new o["a"](-1,0,0);let x=new p["a"];const j=new p["a"];let k=new u["a"];const F=u["a"].IDENTITY.clone(),H=new o["a"],M=new r["a"],V=new o["a"];function U(e,t,a,n,r,i,c,s){let l=H,h=M;x=d["a"].eastNorthUpToFixedFrame(e,r,x),l=p["a"].multiplyByPointAsVector(x,D,l),l=o["a"].normalize(l,l);const g=C(l,t,e,r);k=u["a"].fromRotationZ(g,k),V.z=i,x=p["a"].multiplyTransformation(x,p["a"].fromRotationTranslation(k,V,j),x);const f=F;f[0]=c;for(let d=0;d<s;d++)for(let e=0;e<a.length;e+=3)h=o["a"].fromArray(a,e,h),h=u["a"].multiplyByVector(f,h,h),h=p["a"].multiplyByPoint(x,h,h),n.push(h.x,h.y,h.z);return n}const z=new o["a"];function W(e,t,a,n,r,i,c){for(let s=0;s<e.length;s+=3){const l=o["a"].fromArray(e,s,z);n=U(l,t,a,n,r,i[s/3],c,1)}return n}function Y(e,t){const a=e.length,n=new Array(6*a);let o=0;const r=t.x+t.width/2,i=t.y+t.height/2;let c=e[0];n[o++]=c.x-r,n[o++]=0,n[o++]=c.y-i;for(let s=1;s<a;s++){c=e[s];const t=c.x-r,a=c.y-i;n[o++]=t,n[o++]=0,n[o++]=a,n[o++]=t,n[o++]=0,n[o++]=a}return c=e[0],n[o++]=c.x-r,n[o++]=0,n[o++]=c.y-i,n}function X(e,t){const a=e.length,n=new Array(3*a);let o=0;const r=t.x+t.width/2,i=t.y+t.height/2;for(let c=0;c<a;c++)n[o++]=e[c].x-r,n[o++]=0,n[o++]=e[c].y-i;return n}const q=new g["a"],$=new o["a"],K=new u["a"];function Z(e,t,a,n,r,i,s,p,h,d){const f=o["a"].angleBetween(o["a"].subtract(t,e,R),o["a"].subtract(a,e,L)),m=n===c["a"].BEVELED?0:Math.ceil(f/l["a"].toRadians(5));let y,_,b;if(y=r?u["a"].fromQuaternion(g["a"].fromAxisAngle(o["a"].negate(e,R),f/(m+1),q),K):u["a"].fromQuaternion(g["a"].fromAxisAngle(e,f/(m+1),q),K),t=o["a"].clone(t,$),m>0){const a=d?2:1;for(let n=0;n<m;n++)t=u["a"].multiplyByVector(y,t,t),_=o["a"].subtract(t,e,R),_=o["a"].normalize(_,_),r||(_=o["a"].negate(_,_)),b=i.scaleToGeodeticSurface(t,L),s=U(b,_,p,s,i,h,1,a)}else _=o["a"].subtract(t,e,R),_=o["a"].normalize(_,_),r||(_=o["a"].negate(_,_)),b=i.scaleToGeodeticSurface(t,L),s=U(b,_,p,s,i,h,1,1),a=o["a"].clone(a,$),_=o["a"].subtract(a,e,R),_=o["a"].normalize(_,_),r||(_=o["a"].negate(_,_)),b=i.scaleToGeodeticSurface(a,L),s=U(b,_,p,s,i,h,1,1);return s}I.removeDuplicatesFromShape=function(e){const t=e.length,a=[];for(let o=t-1,r=0;r<t;o=r++){const t=e[o],i=e[r];n["a"].equals(t,i)||a.push(i)}return a},I.angleIsGreaterThanPi=function(e,t,a,n){const r=new s["a"](a,n),i=r.projectPointOntoPlane(o["a"].add(a,e,v),v),c=r.projectPointOntoPlane(o["a"].add(a,t,N),N);return c.x*i.y-c.y*i.x>=0};const J=new o["a"],Q=new o["a"];I.computePositions=function(e,t,a,n,r){const i=n._ellipsoid,s=G(e,i),u=n._granularity,p=n._cornerType,g=r?Y(t,a):X(t,a),d=r?X(t,a):void 0,L=a.height/2,B=a.width/2;let v=e.length,N=[],C=r?[]:void 0,D=y,x=_,j=b,k=T,F=E,H=A,M=P,V=w,z=O,q=e[0],$=e[1];k=i.geodeticSurfaceNormal(q,k),D=o["a"].subtract($,q,D),D=o["a"].normalize(D,D),V=o["a"].cross(k,D,V),V=o["a"].normalize(V,V);let K,ee,te=s[0],ae=s[1];r&&(C=U(q,V,d,C,i,te+L,1,1)),z=o["a"].clone(q,z),q=$,x=o["a"].negate(D,x);for(let y=1;y<v-1;y++){const t=r?2:1;if($=e[y+1],q.equals($)){Object(f["a"])("Positions are too close and are considered equivalent with rounding error.");continue}D=o["a"].subtract($,q,D),D=o["a"].normalize(D,D),j=o["a"].add(D,x,j),j=o["a"].normalize(j,j),k=i.geodeticSurfaceNormal(q,k);const a=o["a"].multiplyByScalar(k,o["a"].dot(D,k),J);o["a"].subtract(D,a,a),o["a"].normalize(a,a);const n=o["a"].multiplyByScalar(k,o["a"].dot(x,k),Q);o["a"].subtract(x,n,n),o["a"].normalize(n,n);const d=!l["a"].equalsEpsilon(Math.abs(o["a"].dot(a,n)),1,l["a"].EPSILON7);if(d){j=o["a"].cross(j,k,j),j=o["a"].cross(k,j,j),j=o["a"].normalize(j,j);const e=1/Math.max(.25,o["a"].magnitude(o["a"].cross(j,x,R))),a=I.angleIsGreaterThanPi(D,x,q,i);a?(F=o["a"].add(q,o["a"].multiplyByScalar(j,e*B,j),F),H=o["a"].add(F,o["a"].multiplyByScalar(V,B,H),H),m[0]=o["a"].clone(z,m[0]),m[1]=o["a"].clone(H,m[1]),K=S(m,te+L,ae+L,u),ee=h["a"].generateArc({positions:m,granularity:u,ellipsoid:i}),N=W(ee,V,g,N,i,K,1),V=o["a"].cross(k,D,V),V=o["a"].normalize(V,V),M=o["a"].add(F,o["a"].multiplyByScalar(V,B,M),M),p===c["a"].ROUNDED||p===c["a"].BEVELED?Z(F,H,M,p,a,i,N,g,ae+L,r):(j=o["a"].negate(j,j),N=U(q,j,g,N,i,ae+L,e,t)),z=o["a"].clone(M,z)):(F=o["a"].add(q,o["a"].multiplyByScalar(j,e*B,j),F),H=o["a"].add(F,o["a"].multiplyByScalar(V,-B,H),H),m[0]=o["a"].clone(z,m[0]),m[1]=o["a"].clone(H,m[1]),K=S(m,te+L,ae+L,u),ee=h["a"].generateArc({positions:m,granularity:u,ellipsoid:i}),N=W(ee,V,g,N,i,K,1),V=o["a"].cross(k,D,V),V=o["a"].normalize(V,V),M=o["a"].add(F,o["a"].multiplyByScalar(V,-B,M),M),p===c["a"].ROUNDED||p===c["a"].BEVELED?Z(F,H,M,p,a,i,N,g,ae+L,r):N=U(q,j,g,N,i,ae+L,e,t),z=o["a"].clone(M,z)),x=o["a"].negate(D,x)}else N=U(z,V,g,N,i,te+L,1,1),z=q;te=ae,ae=s[y+1],q=$}m[0]=o["a"].clone(z,m[0]),m[1]=o["a"].clone(q,m[1]),K=S(m,te+L,ae+L,u),ee=h["a"].generateArc({positions:m,granularity:u,ellipsoid:i}),N=W(ee,V,g,N,i,K,1),r&&(C=U(q,V,d,C,i,ae+L,1,1)),v=N.length;const ne=r?v+C.length:v,oe=new Float64Array(ne);return oe.set(N),r&&oe.set(C,v),oe},t["a"]=I},"31af":function(e,t,a){"use strict";var n=a("be18"),o=a("bef8"),r=a("535a"),i=a("2f63"),c=a("c52f"),s=a("1e13"),l=a("cef8"),u=a("5410"),p=a("93da"),h=a("52f0"),g=a("188e");const d={numberOfPoints:function(e,t,a){const o=n["a"].distance(e,t);return Math.ceil(o/a)},numberOfPointsRhumbLine:function(e,t,a){const n=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(n/(a*a))))}},f=new o["a"];d.extractHeights=function(e,t){const a=e.length,n=new Array(a);for(let o=0;o<a;o++){const a=e[o];n[o]=t.cartesianToCartographic(a,f).height}return n};const m=new h["a"],y=new n["a"],_=new n["a"],b=new g["a"](n["a"].UNIT_X,0),T=new n["a"],E=new g["a"](n["a"].UNIT_X,0),A=new n["a"],P=new n["a"],w=[];function O(e,t,a){const n=w;let o;if(n.length=e,t===a){for(o=0;o<e;o++)n[o]=t;return n}const r=a-t,i=r/e;for(o=0;o<e;o++){const e=t+o*i;n[o]=e}return n}const R=new o["a"],L=new o["a"],I=new n["a"],B=new n["a"],G=new n["a"],S=new s["a"];let v=new l["a"];function N(e,t,a,o,r,i,c,s){const l=o.scaleToGeodeticSurface(e,B),u=o.scaleToGeodeticSurface(t,G),p=d.numberOfPoints(e,t,a),h=o.cartesianToCartographic(l,R),g=o.cartesianToCartographic(u,L),f=O(p,r,i);S.setEndPoints(h,g);const m=S.surfaceDistance/p;let y=s;h.height=r;let _=o.cartographicToCartesian(h,I);n["a"].pack(_,c,y),y+=3;for(let d=1;d<p;d++){const e=S.interpolateUsingSurfaceDistance(d*m,L);e.height=f[d],_=o.cartographicToCartesian(e,I),n["a"].pack(_,c,y),y+=3}return y}function C(e,t,a,o,r,i,c,s){const u=o.cartesianToCartographic(e,R),p=o.cartesianToCartographic(t,L),h=d.numberOfPointsRhumbLine(u,p,a);u.height=0,p.height=0;const g=O(h,r,i);v.ellipsoid.equals(o)||(v=new l["a"](void 0,void 0,o)),v.setEndPoints(u,p);const f=v.surfaceDistance/h;let m=s;u.height=r;let y=o.cartographicToCartesian(u,I);n["a"].pack(y,c,m),m+=3;for(let l=1;l<h;l++){const e=v.interpolateUsingSurfaceDistance(l*f,L);e.height=g[l],y=o.cartographicToCartesian(e,I),n["a"].pack(y,c,m),m+=3}return m}d.wrapLongitude=function(e,t){const a=[],o=[];if(Object(i["a"])(e)&&e.length>0){t=Object(r["a"])(t,h["a"].IDENTITY);const c=h["a"].inverseTransformation(t,m),s=h["a"].multiplyByPoint(c,n["a"].ZERO,y),l=n["a"].normalize(h["a"].multiplyByPointAsVector(c,n["a"].UNIT_Y,_),_),p=g["a"].fromPointNormal(s,l,b),d=n["a"].normalize(h["a"].multiplyByPointAsVector(c,n["a"].UNIT_X,T),T),f=g["a"].fromPointNormal(s,d,E);let w=1;a.push(n["a"].clone(e[0]));let O=a[0];const R=e.length;for(let t=1;t<R;++t){const r=e[t];if(g["a"].getPointDistance(f,O)<0||g["a"].getPointDistance(f,r)<0){const e=u["a"].lineSegmentPlane(O,r,p,A);if(Object(i["a"])(e)){const t=n["a"].multiplyByScalar(l,5e-9,P);g["a"].getPointDistance(p,O)<0&&n["a"].negate(t,t),a.push(n["a"].add(e,t,new n["a"])),o.push(w+1),n["a"].negate(t,t),a.push(n["a"].add(e,t,new n["a"])),w=1}}a.push(n["a"].clone(e[t])),w++,O=r}o.push(w)}return{positions:a,lengths:o}},d.generateArc=function(e){Object(i["a"])(e)||(e={});const t=e.positions,a=t.length,o=Object(r["a"])(e.ellipsoid,c["a"].WGS84);let s=Object(r["a"])(e.height,0);const l=Array.isArray(s);if(a<1)return[];if(1===a){const e=o.scaleToGeodeticSurface(t[0],B);if(s=l?s[0]:s,0!==s){const t=o.geodeticSurfaceNormal(e,I);n["a"].multiplyByScalar(t,s,t),n["a"].add(e,t,e)}return[e.x,e.y,e.z]}let u=e.minDistance;if(!Object(i["a"])(u)){const t=Object(r["a"])(e.granularity,p["a"].RADIANS_PER_DEGREE);u=p["a"].chordLength(t,o.maximumRadius)}let h,g=0;for(h=0;h<a-1;h++)g+=d.numberOfPoints(t[h],t[h+1],u);const f=3*(g+1),m=new Array(f);let y=0;for(h=0;h<a-1;h++){const e=t[h],a=t[h+1],n=l?s[h]:s,r=l?s[h+1]:s;y=N(e,a,u,o,n,r,m,y)}w.length=0;const _=t[a-1],b=o.cartesianToCartographic(_,R);b.height=l?s[a-1]:s;const T=o.cartographicToCartesian(b,I);return n["a"].pack(T,m,f-3),m};const D=new o["a"],x=new o["a"];d.generateRhumbArc=function(e){Object(i["a"])(e)||(e={});const t=e.positions,a=t.length,s=Object(r["a"])(e.ellipsoid,c["a"].WGS84);let l=Object(r["a"])(e.height,0);const u=Array.isArray(l);if(a<1)return[];if(1===a){const e=s.scaleToGeodeticSurface(t[0],B);if(l=u?l[0]:l,0!==l){const t=s.geodeticSurfaceNormal(e,I);n["a"].multiplyByScalar(t,l,t),n["a"].add(e,t,e)}return[e.x,e.y,e.z]}const h=Object(r["a"])(e.granularity,p["a"].RADIANS_PER_DEGREE);let g,f,m=0,y=s.cartesianToCartographic(t[0],D);for(g=0;g<a-1;g++)f=s.cartesianToCartographic(t[g+1],x),m+=d.numberOfPointsRhumbLine(y,f,h),y=o["a"].clone(f,D);const _=3*(m+1),b=new Array(_);let T=0;for(g=0;g<a-1;g++){const e=t[g],a=t[g+1],n=u?l[g]:l,o=u?l[g+1]:l;T=C(e,a,h,s,n,o,b,T)}w.length=0;const E=t[a-1],A=s.cartesianToCartographic(E,R);A.height=u?l[a-1]:l;const P=s.cartographicToCartesian(A,I);return n["a"].pack(P,b,_-3),b},d.generateCartesianArc=function(e){const t=d.generateArc(e),a=t.length/3,o=new Array(a);for(let r=0;r<a;r++)o[r]=n["a"].unpack(t,3*r);return o},d.generateCartesianRhumbArc=function(e){const t=d.generateRhumbArc(e),a=t.length/3,o=new Array(a);for(let r=0;r<a;r++)o[r]=n["a"].unpack(t,3*r);return o},t["a"]=d},4914:function(e,t,a){"use strict";var n=a("9201"),o=a("2c34"),r=a("77af"),i=a("cef5"),c=a("670c"),s=a("be18"),l=a("bef8"),u=a("abab"),p=a("535a"),h=a("2f63"),g=a("c52f"),d=a("1e13"),f=a("a3bd"),m=a("d2c7"),y=a("81d7"),_=a("d940"),b=a("0276"),T=a("c1e2"),E=a("0123"),A=a("93da"),P=a("df07"),w=a("24e4"),O=a("9251"),R=a("0260"),L=a("eace"),I=a("0541"),B=a("b48e");const G=new l["a"],S=new l["a"];function v(e,t,a,n){const o=n.cartesianToCartographic(e,G),r=o.height,i=n.cartesianToCartographic(t,S);i.height=r,n.cartographicToCartesian(i,t);const c=n.cartesianToCartographic(a,S);c.height=r-100,n.cartographicToCartesian(c,a)}const N=new r["a"],C=new s["a"],D=new s["a"],x=new s["a"],j=new s["a"],k=new s["a"],F=new s["a"];let H=new s["a"],M=new s["a"],V=new s["a"];const U=new c["a"],z=new c["a"],W=new s["a"],Y=new R["a"],X=new P["a"],q=new P["a"];function $(e){const t=e.vertexFormat,a=e.geometry,n=e.shadowVolume,r=a.attributes.position.values;let i=r.length;const l=e.wall,p=e.top||l,g=e.bottom||l;if(t.st||t.normal||t.tangent||t.bitangent||n){const o=e.boundingRectangle,h=e.tangentPlane,d=e.ellipsoid,f=e.stRotation,m=e.perPositionHeight,_=U;_.x=o.x,_.y=o.y;const b=t.st?new Float32Array(i/3*2):void 0;let T;t.normal&&(T=m&&p&&!l?a.attributes.normal.values:new Float32Array(i));const E=t.tangent?new Float32Array(i):void 0,w=t.bitangent?new Float32Array(i):void 0,O=n?new Float32Array(i):void 0;let L=0,I=0,B=D,G=x,S=j,N=!0,$=X,K=q;if(0!==f){let e=R["a"].fromAxisAngle(h._plane.normal,f,Y);$=P["a"].fromQuaternion(e,$),e=R["a"].fromAxisAngle(h._plane.normal,-f,Y),K=P["a"].fromQuaternion(e,K)}else $=P["a"].clone(P["a"].IDENTITY,$),K=P["a"].clone(P["a"].IDENTITY,K);let Z=0,J=0;p&&g&&(Z=i/2,J=i/3,i/=2);for(let a=0;a<i;a+=3){const u=s["a"].fromArray(r,a,W);if(t.st){let e=P["a"].multiplyByVector($,u,C);e=d.scaleToGeodeticSurface(e,e);const t=h.projectPointOntoPlane(e,z);c["a"].subtract(t,_,t);const a=A["a"].clamp(t.x/o.width,0,1),n=A["a"].clamp(t.y/o.height,0,1);g&&(b[L+J]=a,b[L+1+J]=n),p&&(b[L]=a,b[L+1]=n),L+=2}if(t.normal||t.tangent||t.bitangent||n){const o=I+1,c=I+2;if(l){if(a+3<i){const e=s["a"].fromArray(r,a+3,k);if(N){const t=s["a"].fromArray(r,a+i,F);m&&v(u,e,t,d),s["a"].subtract(e,u,e),s["a"].subtract(t,u,t),B=s["a"].normalize(s["a"].cross(t,e,B),B),N=!1}s["a"].equalsEpsilon(e,u,A["a"].EPSILON10)&&(N=!0)}(t.tangent||t.bitangent)&&(S=d.geodeticSurfaceNormal(u,S),t.tangent&&(G=s["a"].normalize(s["a"].cross(S,B,G),G)))}else B=d.geodeticSurfaceNormal(u,B),(t.tangent||t.bitangent)&&(m&&(H=s["a"].fromArray(T,I,H),M=s["a"].cross(s["a"].UNIT_Z,H,M),M=s["a"].normalize(P["a"].multiplyByVector(K,M,M),M),t.bitangent&&(V=s["a"].normalize(s["a"].cross(H,M,V),V))),G=s["a"].cross(s["a"].UNIT_Z,B,G),G=s["a"].normalize(P["a"].multiplyByVector(K,G,G),G),t.bitangent&&(S=s["a"].normalize(s["a"].cross(B,G,S),S)));t.normal&&(e.wall?(T[I+Z]=B.x,T[o+Z]=B.y,T[c+Z]=B.z):g&&(T[I+Z]=-B.x,T[o+Z]=-B.y,T[c+Z]=-B.z),(p&&!m||l)&&(T[I]=B.x,T[o]=B.y,T[c]=B.z)),n&&(l&&(B=d.geodeticSurfaceNormal(u,B)),O[I+Z]=-B.x,O[o+Z]=-B.y,O[c+Z]=-B.z),t.tangent&&(e.wall?(E[I+Z]=G.x,E[o+Z]=G.y,E[c+Z]=G.z):g&&(E[I+Z]=-G.x,E[o+Z]=-G.y,E[c+Z]=-G.z),p&&(m?(E[I]=M.x,E[o]=M.y,E[c]=M.z):(E[I]=G.x,E[o]=G.y,E[c]=G.z))),t.bitangent&&(g&&(w[I+Z]=S.x,w[o+Z]=S.y,w[c+Z]=S.z),p&&(m?(w[I]=V.x,w[o]=V.y,w[c]=V.z):(w[I]=S.x,w[o]=S.y,w[c]=S.z))),I+=3}}t.st&&(a.attributes.st=new y["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:2,values:b})),t.normal&&(a.attributes.normal=new y["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:T})),t.tangent&&(a.attributes.tangent=new y["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:E})),t.bitangent&&(a.attributes.bitangent=new y["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:w})),n&&(a.attributes.extrudeDirection=new y["a"]({componentDatatype:u["a"].FLOAT,componentsPerAttribute:3,values:O}))}if(e.extrude&&Object(h["a"])(e.offsetAttribute)){const t=r.length/3;let n=new Uint8Array(t);if(e.offsetAttribute===b["a"].TOP)p&&g||l?n=Object(o["a"])(n,1,0,t/2):p&&(n=Object(o["a"])(n,1));else{const t=e.offsetAttribute===b["a"].NONE?0:1;n=Object(o["a"])(n,t)}a.attributes.applyOffset=new y["a"]({componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return a}const K=new l["a"],Z=new l["a"],J={westOverIDL:0,eastOverIDL:0};let Q=new d["a"];function ee(e,t,a,o,r){if(r=Object(p["a"])(r,new L["a"]),!Object(h["a"])(e)||e.length<3)return r.west=0,r.north=0,r.south=0,r.east=0,r;if(a===n["a"].RHUMB)return L["a"].fromCartesianArray(e,t,r);Q.ellipsoid.equals(t)||(Q=new d["a"](void 0,void 0,t)),r.west=Number.POSITIVE_INFINITY,r.east=Number.NEGATIVE_INFINITY,r.south=Number.POSITIVE_INFINITY,r.north=Number.NEGATIVE_INFINITY,J.westOverIDL=Number.POSITIVE_INFINITY,J.eastOverIDL=Number.NEGATIVE_INFINITY;const i=1/A["a"].chordLength(o,t.maximumRadius),c=e.length;let s,l=t.cartesianToCartographic(e[0],Z),u=K;for(let n=1;n<c;n++)s=u,u=l,l=t.cartesianToCartographic(e[n],s),Q.setEndPoints(u,l),ae(Q,i,r,J);return s=u,u=l,l=t.cartesianToCartographic(e[0],s),Q.setEndPoints(u,l),ae(Q,i,r,J),r.east-r.west>J.eastOverIDL-J.westOverIDL&&(r.west=J.westOverIDL,r.east=J.eastOverIDL,r.east>A["a"].PI&&(r.east=r.east-A["a"].TWO_PI),r.west>A["a"].PI&&(r.west=r.west-A["a"].TWO_PI)),r}const te=new l["a"];function ae(e,t,a,n){const o=e.surfaceDistance,r=Math.ceil(o*t),i=r>0?o/(r-1):Number.POSITIVE_INFINITY;let c=0;for(let s=0;s<r;s++){const t=e.interpolateUsingSurfaceDistance(c,te);c+=i;const o=t.longitude,r=t.latitude;a.west=Math.min(a.west,o),a.east=Math.max(a.east,o),a.south=Math.min(a.south,r),a.north=Math.max(a.north,r);const s=o>=0?o:o+A["a"].TWO_PI;n.westOverIDL=Math.min(n.westOverIDL,s),n.eastOverIDL=Math.max(n.eastOverIDL,s)}}const ne=[];function oe(e,t,a,n,o,r,i,c,s){const l={walls:[]};let u;if(r||i){const n=w["a"].createGeometryFromPositions(e,t,a,o,c,s),p=n.attributes.position.values,h=n.indices;let g,d;if(r&&i){const e=p.concat(p);g=e.length/3,d=E["a"].createTypedArray(g,2*h.length),d.set(h);const t=h.length,a=g/2;for(u=0;u<t;u+=3){const e=d[u]+a,n=d[u+1]+a,o=d[u+2]+a;d[u+t]=o,d[u+1+t]=n,d[u+2+t]=e}if(n.attributes.position.values=e,o&&c.normal){const t=n.attributes.normal.values;n.attributes.normal.values=new Float32Array(e.length),n.attributes.normal.values.set(t)}n.indices=d}else if(i){for(g=p.length/3,d=E["a"].createTypedArray(g,h.length),u=0;u<h.length;u+=3)d[u]=h[u+2],d[u+1]=h[u+1],d[u+2]=h[u];n.indices=d}l.topAndBottom=new _["a"]({geometry:n})}let p=n.outerRing,h=f["a"].fromPoints(p,e),g=h.projectPointsOntoPlane(p,ne),d=O["a"].computeWindingOrder2D(g);d===B["a"].CLOCKWISE&&(p=p.slice().reverse());let m=w["a"].computeWallGeometry(p,e,a,o,s);l.walls.push(new _["a"]({geometry:m}));const y=n.holes;for(u=0;u<y.length;u++){let t=y[u];h=f["a"].fromPoints(t,e),g=h.projectPointsOntoPlane(t,ne),d=O["a"].computeWindingOrder2D(g),d===B["a"].COUNTER_CLOCKWISE&&(t=t.slice().reverse()),m=w["a"].computeWallGeometry(t,e,a,o,s),l.walls.push(new _["a"]({geometry:m}))}return l}function re(e){const t=e.polygonHierarchy,a=Object(p["a"])(e.vertexFormat,I["a"].DEFAULT),o=Object(p["a"])(e.ellipsoid,g["a"].WGS84),r=Object(p["a"])(e.granularity,A["a"].RADIANS_PER_DEGREE),i=Object(p["a"])(e.stRotation,0),c=Object(p["a"])(e.perPositionHeight,!1),s=c&&Object(h["a"])(e.extrudedHeight);let l=Object(p["a"])(e.height,0),u=Object(p["a"])(e.extrudedHeight,l);if(!s){const e=Math.max(l,u);u=Math.min(l,u),l=e}this._vertexFormat=I["a"].clone(a),this._ellipsoid=g["a"].clone(o),this._granularity=r,this._stRotation=i,this._height=l,this._extrudedHeight=u,this._closeTop=Object(p["a"])(e.closeTop,!0),this._closeBottom=Object(p["a"])(e.closeBottom,!0),this._polygonHierarchy=t,this._perPositionHeight=c,this._perPositionHeightExtrude=s,this._shadowVolume=Object(p["a"])(e.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=e.offsetAttribute,this._arcType=Object(p["a"])(e.arcType,n["a"].GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this.packedLength=w["a"].computeHierarchyPackedLength(t)+g["a"].packedLength+I["a"].packedLength+12}re.fromPositions=function(e){e=Object(p["a"])(e,p["a"].EMPTY_OBJECT);const t={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,closeTop:e.closeTop,closeBottom:e.closeBottom,offsetAttribute:e.offsetAttribute,arcType:e.arcType};return new re(t)},re.pack=function(e,t,a){return a=Object(p["a"])(a,0),a=w["a"].packPolygonHierarchy(e._polygonHierarchy,t,a),g["a"].pack(e._ellipsoid,t,a),a+=g["a"].packedLength,I["a"].pack(e._vertexFormat,t,a),a+=I["a"].packedLength,t[a++]=e._height,t[a++]=e._extrudedHeight,t[a++]=e._granularity,t[a++]=e._stRotation,t[a++]=e._perPositionHeightExtrude?1:0,t[a++]=e._perPositionHeight?1:0,t[a++]=e._closeTop?1:0,t[a++]=e._closeBottom?1:0,t[a++]=e._shadowVolume?1:0,t[a++]=Object(p["a"])(e._offsetAttribute,-1),t[a++]=e._arcType,t[a]=e.packedLength,t};const ie=g["a"].clone(g["a"].UNIT_SPHERE),ce=new I["a"],se={polygonHierarchy:{}};function le(e){const t=-e._stRotation;if(0===t)return[0,0,0,1,1,0];const a=e._ellipsoid,n=e._polygonHierarchy.positions,o=e.rectangle;return m["a"]._textureCoordinateRotationPoints(n,t,a,o)}re.unpack=function(e,t,a){t=Object(p["a"])(t,0);const n=w["a"].unpackPolygonHierarchy(e,t);t=n.startingIndex,delete n.startingIndex;const o=g["a"].unpack(e,t,ie);t+=g["a"].packedLength;const r=I["a"].unpack(e,t,ce);t+=I["a"].packedLength;const i=e[t++],c=e[t++],s=e[t++],l=e[t++],u=1===e[t++],d=1===e[t++],f=1===e[t++],m=1===e[t++],y=1===e[t++],_=e[t++],b=e[t++],T=e[t];return Object(h["a"])(a)||(a=new re(se)),a._polygonHierarchy=n,a._ellipsoid=g["a"].clone(o,a._ellipsoid),a._vertexFormat=I["a"].clone(r,a._vertexFormat),a._height=i,a._extrudedHeight=c,a._granularity=s,a._stRotation=l,a._perPositionHeightExtrude=u,a._perPositionHeight=d,a._closeTop=f,a._closeBottom=m,a._shadowVolume=y,a._offsetAttribute=-1===_?void 0:_,a._arcType=b,a.packedLength=T,a},re.computeRectangle=function(e,t){const a=Object(p["a"])(e.granularity,A["a"].RADIANS_PER_DEGREE),o=Object(p["a"])(e.arcType,n["a"].GEODESIC),r=e.polygonHierarchy,i=Object(p["a"])(e.ellipsoid,g["a"].WGS84);return ee(r.positions,i,o,a,t)},re.createGeometry=function(e){const t=e._vertexFormat,a=e._ellipsoid,n=e._granularity,r=e._stRotation,c=e._polygonHierarchy,s=e._perPositionHeight,l=e._closeTop,p=e._closeBottom,g=e._arcType;let d=c.positions;if(d.length<3)return;const P=f["a"].fromPoints(d,a),R=w["a"].polygonsFromHierarchy(c,P.projectPointsOntoPlane.bind(P),!s,a),L=R.hierarchy,I=R.polygons;if(0===L.length)return;d=L[0].outerRing;const B=w["a"].computeBoundingRectangle(P.plane.normal,P.projectPointOntoPlane.bind(P),d,r,N),G=[],S=e._height,v=e._extrudedHeight,C=e._perPositionHeightExtrude||!A["a"].equalsEpsilon(S,v,0,A["a"].EPSILON2),D={perPositionHeight:s,vertexFormat:t,geometry:void 0,tangentPlane:P,boundingRectangle:B,ellipsoid:a,stRotation:r,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:g};let x;if(C)for(D.extrude=!0,D.top=l,D.bottom=p,D.shadowVolume=e._shadowVolume,D.offsetAttribute=e._offsetAttribute,x=0;x<I.length;x++){const e=oe(a,I[x],n,L[x],s,l,p,t,g);let o;l&&p?(o=e.topAndBottom,D.geometry=w["a"].scaleToGeodeticHeightExtruded(o.geometry,S,v,a,s)):l?(o=e.topAndBottom,o.geometry.attributes.position.values=O["a"].scaleToGeodeticHeight(o.geometry.attributes.position.values,S,a,!s),D.geometry=o.geometry):p&&(o=e.topAndBottom,o.geometry.attributes.position.values=O["a"].scaleToGeodeticHeight(o.geometry.attributes.position.values,v,a,!0),D.geometry=o.geometry),(l||p)&&(D.wall=!1,o.geometry=$(D),G.push(o));const r=e.walls;D.wall=!0;for(let t=0;t<r.length;t++){const e=r[t];D.geometry=w["a"].scaleToGeodeticHeightExtruded(e.geometry,S,v,a,s),e.geometry=$(D),G.push(e)}}else for(x=0;x<I.length;x++){const r=new _["a"]({geometry:w["a"].createGeometryFromPositions(a,I[x],n,s,t,g)});if(r.geometry.attributes.position.values=O["a"].scaleToGeodeticHeight(r.geometry.attributes.position.values,S,a,!s),D.geometry=r.geometry,r.geometry=$(D),Object(h["a"])(e._offsetAttribute)){const t=r.geometry.attributes.position.values.length,a=new Uint8Array(t/3),n=e._offsetAttribute===b["a"].NONE?0:1;Object(o["a"])(a,n),r.geometry.attributes.applyOffset=new y["a"]({componentDatatype:u["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}G.push(r)}const j=T["a"].combineInstances(G)[0];j.attributes.position.values=new Float64Array(j.attributes.position.values),j.indices=E["a"].createTypedArray(j.attributes.position.values.length/3,j.indices);const k=j.attributes,F=i["a"].fromVertices(k.position.values);return t.position||delete k.position,new m["a"]({attributes:k,indices:j.indices,primitiveType:j.primitiveType,boundingSphere:F,offsetAttribute:e._offsetAttribute})},re.createShadowVolume=function(e,t,a){const n=e._granularity,o=e._ellipsoid,r=t(n,o),i=a(n,o);return new re({polygonHierarchy:e._polygonHierarchy,ellipsoid:o,stRotation:e._stRotation,granularity:n,perPositionHeight:!1,extrudedHeight:r,height:i,vertexFormat:I["a"].POSITION_ONLY,shadowVolume:!0,arcType:e._arcType})},Object.defineProperties(re.prototype,{rectangle:{get:function(){if(!Object(h["a"])(this._rectangle)){const e=this._polygonHierarchy.positions;this._rectangle=ee(e,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return Object(h["a"])(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=le(this)),this._textureCoordinateRotationPoints}}}),t["a"]=re},"7bf4":function(e,t,a){"use strict";var n=a("9201"),o=a("2c34"),r=a("cef5"),i=a("abab"),c=a("535a"),s=a("2f63"),l=a("c52f"),u=a("a3bd"),p=a("d2c7"),h=a("81d7"),g=a("473c"),d=a("d940"),f=a("0276"),m=a("c1e2"),y=a("0123"),_=a("93da"),b=a("24e4"),T=a("9251"),E=a("1b8d"),A=a("b48e");const P=[],w=[];function O(e,t,a,o,r){const c=u["a"].fromPoints(t,e),s=c.projectPointsOntoPlane(t,P),l=T["a"].computeWindingOrder2D(s);let f,m;l===A["a"].CLOCKWISE&&(s.reverse(),t=t.slice().reverse());let _=t.length,O=0;if(o)for(f=new Float64Array(2*_*3),m=0;m<_;m++){const e=t[m],a=t[(m+1)%_];f[O++]=e.x,f[O++]=e.y,f[O++]=e.z,f[O++]=a.x,f[O++]=a.y,f[O++]=a.z}else{let o=0;if(r===n["a"].GEODESIC)for(m=0;m<_;m++)o+=b["a"].subdivideLineCount(t[m],t[(m+1)%_],a);else if(r===n["a"].RHUMB)for(m=0;m<_;m++)o+=b["a"].subdivideRhumbLineCount(e,t[m],t[(m+1)%_],a);for(f=new Float64Array(3*o),m=0;m<_;m++){let o;r===n["a"].GEODESIC?o=b["a"].subdivideLine(t[m],t[(m+1)%_],a,w):r===n["a"].RHUMB&&(o=b["a"].subdivideRhumbLine(e,t[m],t[(m+1)%_],a,w));const i=o.length;for(let e=0;e<i;++e)f[O++]=o[e]}}_=f.length/3;const R=2*_,L=y["a"].createTypedArray(_,R);for(O=0,m=0;m<_-1;m++)L[O++]=m,L[O++]=m+1;return L[O++]=_-1,L[O++]=0,new d["a"]({geometry:new p["a"]({attributes:new g["a"]({position:new h["a"]({componentDatatype:i["a"].DOUBLE,componentsPerAttribute:3,values:f})}),indices:L,primitiveType:E["a"].LINES})})}function R(e,t,a,o,r){const c=u["a"].fromPoints(t,e),s=c.projectPointsOntoPlane(t,P),l=T["a"].computeWindingOrder2D(s);let f,m;l===A["a"].CLOCKWISE&&(s.reverse(),t=t.slice().reverse());let _=t.length;const O=new Array(_);let R=0;if(o)for(f=new Float64Array(2*_*3*2),m=0;m<_;++m){O[m]=R/3;const e=t[m],a=t[(m+1)%_];f[R++]=e.x,f[R++]=e.y,f[R++]=e.z,f[R++]=a.x,f[R++]=a.y,f[R++]=a.z}else{let o=0;if(r===n["a"].GEODESIC)for(m=0;m<_;m++)o+=b["a"].subdivideLineCount(t[m],t[(m+1)%_],a);else if(r===n["a"].RHUMB)for(m=0;m<_;m++)o+=b["a"].subdivideRhumbLineCount(e,t[m],t[(m+1)%_],a);for(f=new Float64Array(3*o*2),m=0;m<_;++m){let o;O[m]=R/3,r===n["a"].GEODESIC?o=b["a"].subdivideLine(t[m],t[(m+1)%_],a,w):r===n["a"].RHUMB&&(o=b["a"].subdivideRhumbLine(e,t[m],t[(m+1)%_],a,w));const i=o.length;for(let e=0;e<i;++e)f[R++]=o[e]}}_=f.length/6;const L=O.length,I=2*(2*_+L),B=y["a"].createTypedArray(_+L,I);for(R=0,m=0;m<_;++m)B[R++]=m,B[R++]=(m+1)%_,B[R++]=m+_,B[R++]=(m+1)%_+_;for(m=0;m<L;m++){const e=O[m];B[R++]=e,B[R++]=e+_}return new d["a"]({geometry:new p["a"]({attributes:new g["a"]({position:new h["a"]({componentDatatype:i["a"].DOUBLE,componentsPerAttribute:3,values:f})}),indices:B,primitiveType:E["a"].LINES})})}function L(e){const t=e.polygonHierarchy,a=Object(c["a"])(e.ellipsoid,l["a"].WGS84),o=Object(c["a"])(e.granularity,_["a"].RADIANS_PER_DEGREE),r=Object(c["a"])(e.perPositionHeight,!1),i=r&&Object(s["a"])(e.extrudedHeight),u=Object(c["a"])(e.arcType,n["a"].GEODESIC);let p=Object(c["a"])(e.height,0),h=Object(c["a"])(e.extrudedHeight,p);if(!i){const e=Math.max(p,h);h=Math.min(p,h),p=e}this._ellipsoid=l["a"].clone(a),this._granularity=o,this._height=p,this._extrudedHeight=h,this._arcType=u,this._polygonHierarchy=t,this._perPositionHeight=r,this._perPositionHeightExtrude=i,this._offsetAttribute=e.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=b["a"].computeHierarchyPackedLength(t)+l["a"].packedLength+8}L.pack=function(e,t,a){return a=Object(c["a"])(a,0),a=b["a"].packPolygonHierarchy(e._polygonHierarchy,t,a),l["a"].pack(e._ellipsoid,t,a),a+=l["a"].packedLength,t[a++]=e._height,t[a++]=e._extrudedHeight,t[a++]=e._granularity,t[a++]=e._perPositionHeightExtrude?1:0,t[a++]=e._perPositionHeight?1:0,t[a++]=e._arcType,t[a++]=Object(c["a"])(e._offsetAttribute,-1),t[a]=e.packedLength,t};const I=l["a"].clone(l["a"].UNIT_SPHERE),B={polygonHierarchy:{}};L.unpack=function(e,t,a){t=Object(c["a"])(t,0);const n=b["a"].unpackPolygonHierarchy(e,t);t=n.startingIndex,delete n.startingIndex;const o=l["a"].unpack(e,t,I);t+=l["a"].packedLength;const r=e[t++],i=e[t++],u=e[t++],p=1===e[t++],h=1===e[t++],g=e[t++],d=e[t++],f=e[t];return Object(s["a"])(a)||(a=new L(B)),a._polygonHierarchy=n,a._ellipsoid=l["a"].clone(o,a._ellipsoid),a._height=r,a._extrudedHeight=i,a._granularity=u,a._perPositionHeight=h,a._perPositionHeightExtrude=p,a._arcType=g,a._offsetAttribute=-1===d?void 0:d,a.packedLength=f,a},L.fromPositions=function(e){e=Object(c["a"])(e,c["a"].EMPTY_OBJECT);const t={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute};return new L(t)},L.createGeometry=function(e){const t=e._ellipsoid,a=e._granularity,n=e._polygonHierarchy,c=e._perPositionHeight,l=e._arcType,u=b["a"].polygonOutlinesFromHierarchy(n,!c,t);if(0===u.length)return;let g;const d=[],y=_["a"].chordLength(a,t.maximumRadius),E=e._height,A=e._extrudedHeight,P=e._perPositionHeightExtrude||!_["a"].equalsEpsilon(E,A,0,_["a"].EPSILON2);let w,L;if(P)for(L=0;L<u.length;L++){if(g=R(t,u[L],y,c,l),g.geometry=b["a"].scaleToGeodeticHeightExtruded(g.geometry,E,A,t,c),Object(s["a"])(e._offsetAttribute)){const t=g.geometry.attributes.position.values.length/3;let a=new Uint8Array(t);e._offsetAttribute===f["a"].TOP?a=Object(o["a"])(a,1,0,t/2):(w=e._offsetAttribute===f["a"].NONE?0:1,a=Object(o["a"])(a,w)),g.geometry.attributes.applyOffset=new h["a"]({componentDatatype:i["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}d.push(g)}else for(L=0;L<u.length;L++){if(g=O(t,u[L],y,c,l),g.geometry.attributes.position.values=T["a"].scaleToGeodeticHeight(g.geometry.attributes.position.values,E,t,!c),Object(s["a"])(e._offsetAttribute)){const t=g.geometry.attributes.position.values.length,a=new Uint8Array(t/3);w=e._offsetAttribute===f["a"].NONE?0:1,Object(o["a"])(a,w),g.geometry.attributes.applyOffset=new h["a"]({componentDatatype:i["a"].UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}d.push(g)}const I=m["a"].combineInstances(d)[0],B=r["a"].fromVertices(I.attributes.position.values);return new p["a"]({attributes:I.attributes,indices:I.indices,primitiveType:I.primitiveType,boundingSphere:B,offsetAttribute:e._offsetAttribute})},t["a"]=L},9251:function(e,t,a){"use strict";var n=a("c20a"),o=a("670c"),r=a("be18"),i=a("bef8"),c=a("abab"),s=a("535a"),l=a("2f63"),u=a("c52f"),p=a("cef8"),h=a("d2c7"),g=a("81d7"),d=a("93da"),f=a("1b8d"),m=a("b48e");const y=new r["a"],_=new r["a"],b={computeArea2D:function(e){const t=e.length;let a=0;for(let n=t-1,o=0;o<t;n=o++){const t=e[n],r=e[o];a+=t.x*r.y-r.x*t.y}return.5*a},computeWindingOrder2D:function(e){const t=b.computeArea2D(e);return t>0?m["a"].COUNTER_CLOCKWISE:m["a"].CLOCKWISE},triangulate:function(e,t){const a=o["a"].packArray(e);return Object(n["a"])(a,t,2)}},T=new r["a"],E=new r["a"],A=new r["a"],P=new r["a"],w=new r["a"],O=new r["a"],R=new r["a"];b.computeSubdivision=function(e,t,a,n){n=Object(s["a"])(n,d["a"].RADIANS_PER_DEGREE);const o=a.slice(0);let i;const u=t.length,p=new Array(3*u);let m=0;for(i=0;i<u;i++){const e=t[i];p[m++]=e.x,p[m++]=e.y,p[m++]=e.z}const y=[],_={},b=e.maximumRadius,L=d["a"].chordLength(n,b),I=L*L;while(o.length>0){const e=o.pop(),t=o.pop(),a=o.pop(),n=r["a"].fromArray(p,3*a,T),c=r["a"].fromArray(p,3*t,E),s=r["a"].fromArray(p,3*e,A),u=r["a"].multiplyByScalar(r["a"].normalize(n,P),b,P),h=r["a"].multiplyByScalar(r["a"].normalize(c,w),b,w),g=r["a"].multiplyByScalar(r["a"].normalize(s,O),b,O),d=r["a"].magnitudeSquared(r["a"].subtract(u,h,R)),f=r["a"].magnitudeSquared(r["a"].subtract(h,g,R)),m=r["a"].magnitudeSquared(r["a"].subtract(g,u,R)),L=Math.max(d,f,m);let B,G;L>I?d===L?(B=`${Math.min(a,t)} ${Math.max(a,t)}`,i=_[B],Object(l["a"])(i)||(G=r["a"].add(n,c,R),r["a"].multiplyByScalar(G,.5,G),p.push(G.x,G.y,G.z),i=p.length/3-1,_[B]=i),o.push(a,i,e),o.push(i,t,e)):f===L?(B=`${Math.min(t,e)} ${Math.max(t,e)}`,i=_[B],Object(l["a"])(i)||(G=r["a"].add(c,s,R),r["a"].multiplyByScalar(G,.5,G),p.push(G.x,G.y,G.z),i=p.length/3-1,_[B]=i),o.push(t,i,a),o.push(i,e,a)):m===L&&(B=`${Math.min(e,a)} ${Math.max(e,a)}`,i=_[B],Object(l["a"])(i)||(G=r["a"].add(s,n,R),r["a"].multiplyByScalar(G,.5,G),p.push(G.x,G.y,G.z),i=p.length/3-1,_[B]=i),o.push(e,i,t),o.push(i,a,t)):(y.push(a),y.push(t),y.push(e))}return new h["a"]({attributes:{position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:p})},indices:y,primitiveType:f["a"].TRIANGLES})};const L=new i["a"],I=new i["a"],B=new i["a"],G=new i["a"];b.computeRhumbLineSubdivision=function(e,t,a,n){n=Object(s["a"])(n,d["a"].RADIANS_PER_DEGREE);const o=a.slice(0);let i;const u=t.length,m=new Array(3*u);let y=0;for(i=0;i<u;i++){const e=t[i];m[y++]=e.x,m[y++]=e.y,m[y++]=e.z}const _=[],b={},P=e.maximumRadius,w=d["a"].chordLength(n,P),O=new p["a"](void 0,void 0,e),S=new p["a"](void 0,void 0,e),v=new p["a"](void 0,void 0,e);while(o.length>0){const t=o.pop(),a=o.pop(),n=o.pop(),c=r["a"].fromArray(m,3*n,T),s=r["a"].fromArray(m,3*a,E),u=r["a"].fromArray(m,3*t,A),p=e.cartesianToCartographic(c,L),h=e.cartesianToCartographic(s,I),g=e.cartesianToCartographic(u,B);O.setEndPoints(p,h);const d=O.surfaceDistance;S.setEndPoints(h,g);const f=S.surfaceDistance;v.setEndPoints(g,p);const y=v.surfaceDistance,P=Math.max(d,f,y);let N,C,D,x;P>w?d===P?(N=`${Math.min(n,a)} ${Math.max(n,a)}`,i=b[N],Object(l["a"])(i)||(C=O.interpolateUsingFraction(.5,G),D=.5*(p.height+h.height),x=r["a"].fromRadians(C.longitude,C.latitude,D,e,R),m.push(x.x,x.y,x.z),i=m.length/3-1,b[N]=i),o.push(n,i,t),o.push(i,a,t)):f===P?(N=`${Math.min(a,t)} ${Math.max(a,t)}`,i=b[N],Object(l["a"])(i)||(C=S.interpolateUsingFraction(.5,G),D=.5*(h.height+g.height),x=r["a"].fromRadians(C.longitude,C.latitude,D,e,R),m.push(x.x,x.y,x.z),i=m.length/3-1,b[N]=i),o.push(a,i,n),o.push(i,t,n)):y===P&&(N=`${Math.min(t,n)} ${Math.max(t,n)}`,i=b[N],Object(l["a"])(i)||(C=v.interpolateUsingFraction(.5,G),D=.5*(g.height+p.height),x=r["a"].fromRadians(C.longitude,C.latitude,D,e,R),m.push(x.x,x.y,x.z),i=m.length/3-1,b[N]=i),o.push(t,i,a),o.push(i,n,a)):(_.push(n),_.push(a),_.push(t))}return new h["a"]({attributes:{position:new g["a"]({componentDatatype:c["a"].DOUBLE,componentsPerAttribute:3,values:m})},indices:_,primitiveType:f["a"].TRIANGLES})},b.scaleToGeodeticHeight=function(e,t,a,n){a=Object(s["a"])(a,u["a"].WGS84);let o=y,i=_;if(t=Object(s["a"])(t,0),n=Object(s["a"])(n,!0),Object(l["a"])(e)){const c=e.length;for(let s=0;s<c;s+=3)r["a"].fromArray(e,s,i),n&&(i=a.scaleToGeodeticSurface(i,i)),0!==t&&(o=a.geodeticSurfaceNormal(i,o),r["a"].multiplyByScalar(o,t,o),r["a"].add(i,o,i)),e[s]=i.x,e[s+1]=i.y,e[s+2]=i.z}return e},t["a"]=b},af94:function(e,t,a){"use strict";var n=a("ee1e"),o=a("77af"),r=a("cef5"),i=a("670c"),c=a("be18"),s=a("abab"),l=a("d0c2"),u=a("535a"),p=a("2f63"),h=a("c52f"),g=a("d2c7"),d=a("81d7"),f=a("473c"),m=a("c1e2"),y=a("0123"),_=a("93da"),b=a("b639"),T=a("9251"),E=a("29bd"),A=a("1b8d"),P=a("0541"),w=a("b48e");function O(e,t,a,n){const o=new f["a"];n.position&&(o.position=new d["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:e}));const i=t.length,c=e.length/3,l=(c-2*i)/(2*i),u=T["a"].triangulate(t),p=(l-1)*i*6+2*u.length,h=y["a"].createTypedArray(c,p);let _,E,P,w,O,R;const L=2*i;let I=0;for(_=0;_<l-1;_++){for(E=0;E<i-1;E++)P=2*E+_*i*2,R=P+L,w=P+1,O=w+L,h[I++]=w,h[I++]=P,h[I++]=O,h[I++]=O,h[I++]=P,h[I++]=R;P=2*i-2+_*i*2,w=P+1,O=w+L,R=P+L,h[I++]=w,h[I++]=P,h[I++]=O,h[I++]=O,h[I++]=P,h[I++]=R}if(n.st||n.tangent||n.bitangent){const e=new Float32Array(2*c),n=1/(l-1),r=1/a.height,u=a.height/2;let p,h,g=0;for(_=0;_<l;_++){for(p=_*n,h=r*(t[0].y+u),e[g++]=p,e[g++]=h,E=1;E<i;E++)h=r*(t[E].y+u),e[g++]=p,e[g++]=h,e[g++]=p,e[g++]=h;h=r*(t[0].y+u),e[g++]=p,e[g++]=h}for(E=0;E<i;E++)p=0,h=r*(t[E].y+u),e[g++]=p,e[g++]=h;for(E=0;E<i;E++)p=(l-1)*n,h=r*(t[E].y+u),e[g++]=p,e[g++]=h;o.st=new d["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:2,values:new Float32Array(e)})}const B=c-2*i;for(_=0;_<u.length;_+=3){const e=u[_]+B,t=u[_+1]+B,a=u[_+2]+B;h[I++]=e,h[I++]=t,h[I++]=a,h[I++]=a+i,h[I++]=t+i,h[I++]=e+i}let G=new g["a"]({attributes:o,indices:h,boundingSphere:r["a"].fromVertices(e),primitiveType:A["a"].TRIANGLES});if(n.normal&&(G=m["a"].computeNormal(G)),n.tangent||n.bitangent){try{G=m["a"].computeTangentAndBitangent(G)}catch(S){Object(b["a"])("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}n.tangent||(G.attributes.tangent=void 0),n.bitangent||(G.attributes.bitangent=void 0),n.st||(G.attributes.st=void 0)}return G}function R(e){e=Object(u["a"])(e,u["a"].EMPTY_OBJECT);const t=e.polylinePositions,a=e.shapePositions;this._positions=t,this._shape=a,this._ellipsoid=h["a"].clone(Object(u["a"])(e.ellipsoid,h["a"].WGS84)),this._cornerType=Object(u["a"])(e.cornerType,l["a"].ROUNDED),this._vertexFormat=P["a"].clone(Object(u["a"])(e.vertexFormat,P["a"].DEFAULT)),this._granularity=Object(u["a"])(e.granularity,_["a"].RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let n=1+t.length*c["a"].packedLength;n+=1+a.length*i["a"].packedLength,this.packedLength=n+h["a"].packedLength+P["a"].packedLength+2}R.pack=function(e,t,a){let n;a=Object(u["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=c["a"].packedLength)c["a"].pack(o[n],t,a);const s=e._shape;for(r=s.length,t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(s[n],t,a);return h["a"].pack(e._ellipsoid,t,a),a+=h["a"].packedLength,P["a"].pack(e._vertexFormat,t,a),a+=P["a"].packedLength,t[a++]=e._cornerType,t[a]=e._granularity,t};const L=h["a"].clone(h["a"].UNIT_SPHERE),I=new P["a"],B={polylinePositions:void 0,shapePositions:void 0,ellipsoid:L,vertexFormat:I,cornerType:void 0,granularity:void 0};R.unpack=function(e,t,a){let n;t=Object(u["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=c["a"].packedLength)r[n]=c["a"].unpack(e,t);o=e[t++];const s=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)s[n]=i["a"].unpack(e,t);const l=h["a"].unpack(e,t,L);t+=h["a"].packedLength;const g=P["a"].unpack(e,t,I);t+=P["a"].packedLength;const d=e[t++],f=e[t];return Object(p["a"])(a)?(a._positions=r,a._shape=s,a._ellipsoid=h["a"].clone(l,a._ellipsoid),a._vertexFormat=P["a"].clone(g,a._vertexFormat),a._cornerType=d,a._granularity=f,a):(B.polylinePositions=r,B.shapePositions=s,B.cornerType=d,B.granularity=f,new R(B))};const G=new o["a"];R.createGeometry=function(e){const t=e._positions,a=Object(n["a"])(t,c["a"].equalsEpsilon);let r=e._shape;if(r=E["a"].removeDuplicatesFromShape(r),a.length<2||r.length<3)return;T["a"].computeWindingOrder2D(r)===w["a"].CLOCKWISE&&r.reverse();const i=o["a"].fromPoints(r,G),s=E["a"].computePositions(a,r,i,e,!0);return O(s,r,i,e._vertexFormat)},t["a"]=R},b999:function(e,t,a){"use strict";var n=a("cef5"),o=a("be18"),r=a("abab"),i=a("2f63"),c=a("d2c7"),s=a("81d7"),l=a("473c"),u=a("1b8d");function p(){this._workerName="createPlaneOutlineGeometry"}p.packedLength=0,p.pack=function(e,t){return t},p.unpack=function(e,t,a){return Object(i["a"])(a)?a:new p};const h=new o["a"](-.5,-.5,0),g=new o["a"](.5,.5,0);p.createGeometry=function(){const e=new l["a"],t=new Uint16Array(8),a=new Float64Array(12);return a[0]=h.x,a[1]=h.y,a[2]=h.z,a[3]=g.x,a[4]=h.y,a[5]=h.z,a[6]=g.x,a[7]=g.y,a[8]=h.z,a[9]=h.x,a[10]=g.y,a[11]=h.z,e.position=new s["a"]({componentDatatype:r["a"].DOUBLE,componentsPerAttribute:3,values:a}),t[0]=0,t[1]=1,t[2]=1,t[3]=2,t[4]=2,t[5]=3,t[6]=3,t[7]=0,new c["a"]({attributes:e,indices:t,primitiveType:u["a"].LINES,boundingSphere:new n["a"](o["a"].ZERO,Math.sqrt(2))})},t["a"]=p},bb71:function(e,t,a){"use strict";var n=a("9201"),o=a("ee1e"),r=a("cef5"),i=a("be18"),c=a("bd8d"),s=a("abab"),l=a("535a"),u=a("2f63"),p=a("c52f"),h=a("d2c7"),g=a("81d7"),d=a("473c"),f=a("3740"),m=a("0123"),y=a("93da"),_=a("31af"),b=a("1b8d"),T=a("0541");const E=[];function A(e,t,a,n,o){const r=E;let i;r.length=o;const s=a.red,l=a.green,u=a.blue,p=a.alpha,h=n.red,g=n.green,d=n.blue,f=n.alpha;if(c["a"].equals(a,n)){for(i=0;i<o;i++)r[i]=c["a"].clone(a);return r}const m=(h-s)/o,y=(g-l)/o,_=(d-u)/o,b=(f-p)/o;for(i=0;i<o;i++)r[i]=new c["a"](s+i*m,l+i*y,u+i*_,p+i*b);return r}function P(e){e=Object(l["a"])(e,l["a"].EMPTY_OBJECT);const t=e.positions,a=e.colors,o=Object(l["a"])(e.width,1),r=Object(l["a"])(e.colorsPerVertex,!1);this._positions=t,this._colors=a,this._width=o,this._colorsPerVertex=r,this._vertexFormat=T["a"].clone(Object(l["a"])(e.vertexFormat,T["a"].DEFAULT)),this._arcType=Object(l["a"])(e.arcType,n["a"].GEODESIC),this._granularity=Object(l["a"])(e.granularity,y["a"].RADIANS_PER_DEGREE),this._ellipsoid=p["a"].clone(Object(l["a"])(e.ellipsoid,p["a"].WGS84)),this._workerName="createPolylineGeometry";let s=1+t.length*i["a"].packedLength;s+=Object(u["a"])(a)?1+a.length*c["a"].packedLength:1,this.packedLength=s+p["a"].packedLength+T["a"].packedLength+4}P.pack=function(e,t,a){let n;a=Object(l["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(o[n],t,a);const s=e._colors;for(r=Object(u["a"])(s)?s.length:0,t[a++]=r,n=0;n<r;++n,a+=c["a"].packedLength)c["a"].pack(s[n],t,a);return p["a"].pack(e._ellipsoid,t,a),a+=p["a"].packedLength,T["a"].pack(e._vertexFormat,t,a),a+=T["a"].packedLength,t[a++]=e._width,t[a++]=e._colorsPerVertex?1:0,t[a++]=e._arcType,t[a]=e._granularity,t};const w=p["a"].clone(p["a"].UNIT_SPHERE),O=new T["a"],R={positions:void 0,colors:void 0,ellipsoid:w,vertexFormat:O,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};P.unpack=function(e,t,a){let n;t=Object(l["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)r[n]=i["a"].unpack(e,t);o=e[t++];const s=o>0?new Array(o):void 0;for(n=0;n<o;++n,t+=c["a"].packedLength)s[n]=c["a"].unpack(e,t);const h=p["a"].unpack(e,t,w);t+=p["a"].packedLength;const g=T["a"].unpack(e,t,O);t+=T["a"].packedLength;const d=e[t++],f=1===e[t++],m=e[t++],y=e[t];return Object(u["a"])(a)?(a._positions=r,a._colors=s,a._ellipsoid=p["a"].clone(h,a._ellipsoid),a._vertexFormat=T["a"].clone(g,a._vertexFormat),a._width=d,a._colorsPerVertex=f,a._arcType=m,a._granularity=y,a):(R.positions=r,R.colors=s,R.width=d,R.colorsPerVertex=f,R.arcType=m,R.granularity=y,new P(R))};const L=new i["a"],I=new i["a"],B=new i["a"],G=new i["a"];P.createGeometry=function(e){const t=e._width,a=e._vertexFormat;let l=e._colors;const p=e._colorsPerVertex,T=e._arcType,P=e._granularity,w=e._ellipsoid;let O,R,S;const v=[];let N=Object(o["a"])(e._positions,i["a"].equalsEpsilon,!1,v);if(Object(u["a"])(l)&&v.length>0){let e=0,t=v[0];l=l.filter((function(a,n){let o=!1;return o=p?n===t||0===n&&1===t:n+1===t,!o||(e++,t=v[e],!1)}))}let C=N.length;if(C<2||t<=0)return;if(T===n["a"].GEODESIC||T===n["a"].RHUMB){let e,t;T===n["a"].GEODESIC?(e=y["a"].chordLength(P,w.maximumRadius),t=_["a"].numberOfPoints):(e=P,t=_["a"].numberOfPointsRhumbLine);const a=_["a"].extractHeights(N,w);if(Object(u["a"])(l)){let a=1;for(O=0;O<C-1;++O)a+=t(N[O],N[O+1],e);const n=new Array(a);let o=0;for(O=0;O<C-1;++O){const r=N[O],i=N[O+1],s=l[O],u=t(r,i,e);if(p&&O<a){const e=l[O+1],t=A(r,i,s,e,u),a=t.length;for(R=0;R<a;++R)n[o++]=t[R]}else for(R=0;R<u;++R)n[o++]=c["a"].clone(s)}n[o]=c["a"].clone(l[l.length-1]),l=n,E.length=0}N=T===n["a"].GEODESIC?_["a"].generateCartesianArc({positions:N,minDistance:e,ellipsoid:w,height:a}):_["a"].generateCartesianRhumbArc({positions:N,granularity:e,ellipsoid:w,height:a})}C=N.length;const D=4*C-4,x=new Float64Array(3*D),j=new Float64Array(3*D),k=new Float64Array(3*D),F=new Float32Array(2*D),H=a.st?new Float32Array(2*D):void 0,M=Object(u["a"])(l)?new Uint8Array(4*D):void 0;let V,U=0,z=0,W=0,Y=0;for(R=0;R<C;++R){let e,n;0===R?(V=L,i["a"].subtract(N[0],N[1],V),i["a"].add(N[0],V,V)):V=N[R-1],i["a"].clone(V,B),i["a"].clone(N[R],I),R===C-1?(V=L,i["a"].subtract(N[C-1],N[C-2],V),i["a"].add(N[C-1],V,V)):V=N[R+1],i["a"].clone(V,G),Object(u["a"])(M)&&(e=0===R||p?l[R]:l[R-1],R!==C-1&&(n=l[R]));const o=0===R?2:0,r=R===C-1?2:4;for(S=o;S<r;++S){i["a"].pack(I,x,U),i["a"].pack(B,j,U),i["a"].pack(G,k,U),U+=3;const o=S-2<0?-1:1;if(F[z++]=S%2*2-1,F[z++]=o*t,a.st&&(H[W++]=R/(C-1),H[W++]=Math.max(F[z-2],0)),Object(u["a"])(M)){const t=S<2?e:n;M[Y++]=c["a"].floatToByte(t.red),M[Y++]=c["a"].floatToByte(t.green),M[Y++]=c["a"].floatToByte(t.blue),M[Y++]=c["a"].floatToByte(t.alpha)}}}const X=new d["a"];X.position=new g["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:x}),X.prevPosition=new g["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:j}),X.nextPosition=new g["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:k}),X.expandAndWidth=new g["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:2,values:F}),a.st&&(X.st=new g["a"]({componentDatatype:s["a"].FLOAT,componentsPerAttribute:2,values:H})),Object(u["a"])(M)&&(X.color=new g["a"]({componentDatatype:s["a"].UNSIGNED_BYTE,componentsPerAttribute:4,values:M,normalize:!0}));const q=m["a"].createTypedArray(D,6*C-6);let $=0,K=0;const Z=C-1;for(R=0;R<Z;++R)q[K++]=$,q[K++]=$+2,q[K++]=$+1,q[K++]=$+1,q[K++]=$+2,q[K++]=$+3,$+=4;return new h["a"]({attributes:X,indices:q,primitiveType:b["a"].TRIANGLES,boundingSphere:r["a"].fromPoints(N),geometryType:f["a"].POLYLINES})},t["a"]=P},cb22:function(e,t,a){"use strict";var n=a("4f04");function o(){n["a"].throwInstantiationError()}o.prototype.getURL=n["a"].throwInstantiationError,t["a"]=o},e42d:function(e,t,a){"use strict";var n=a("6ef5"),o=a("daa2");const r={DEPTH_COMPONENT:o["a"].DEPTH_COMPONENT,DEPTH_STENCIL:o["a"].DEPTH_STENCIL,ALPHA:o["a"].ALPHA,RGB:o["a"].RGB,RGBA:o["a"].RGBA,LUMINANCE:o["a"].LUMINANCE,LUMINANCE_ALPHA:o["a"].LUMINANCE_ALPHA,RGB_DXT1:o["a"].COMPRESSED_RGB_S3TC_DXT1_EXT,RGBA_DXT1:o["a"].COMPRESSED_RGBA_S3TC_DXT1_EXT,RGBA_DXT3:o["a"].COMPRESSED_RGBA_S3TC_DXT3_EXT,RGBA_DXT5:o["a"].COMPRESSED_RGBA_S3TC_DXT5_EXT,RGB_PVRTC_4BPPV1:o["a"].COMPRESSED_RGB_PVRTC_4BPPV1_IMG,RGB_PVRTC_2BPPV1:o["a"].COMPRESSED_RGB_PVRTC_2BPPV1_IMG,RGBA_PVRTC_4BPPV1:o["a"].COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,RGBA_PVRTC_2BPPV1:o["a"].COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,RGBA_ASTC:o["a"].COMPRESSED_RGBA_ASTC_4x4_WEBGL,RGB_ETC1:o["a"].COMPRESSED_RGB_ETC1_WEBGL,RGB8_ETC2:o["a"].COMPRESSED_RGB8_ETC2,RGBA8_ETC2_EAC:o["a"].COMPRESSED_RGBA8_ETC2_EAC,RGBA_BC7:o["a"].COMPRESSED_RGBA_BPTC_UNORM,componentsLength:function(e){switch(e){case r.RGB:return 3;case r.RGBA:return 4;case r.LUMINANCE_ALPHA:return 2;case r.ALPHA:case r.LUMINANCE:return 1;default:return 1}},validate:function(e){return e===r.DEPTH_COMPONENT||e===r.DEPTH_STENCIL||e===r.ALPHA||e===r.RGB||e===r.RGBA||e===r.LUMINANCE||e===r.LUMINANCE_ALPHA||e===r.RGB_DXT1||e===r.RGBA_DXT1||e===r.RGBA_DXT3||e===r.RGBA_DXT5||e===r.RGB_PVRTC_4BPPV1||e===r.RGB_PVRTC_2BPPV1||e===r.RGBA_PVRTC_4BPPV1||e===r.RGBA_PVRTC_2BPPV1||e===r.RGBA_ASTC||e===r.RGB_ETC1||e===r.RGB8_ETC2||e===r.RGBA8_ETC2_EAC||e===r.RGBA_BC7},isColorFormat:function(e){return e===r.ALPHA||e===r.RGB||e===r.RGBA||e===r.LUMINANCE||e===r.LUMINANCE_ALPHA},isDepthFormat:function(e){return e===r.DEPTH_COMPONENT||e===r.DEPTH_STENCIL},isCompressedFormat:function(e){return e===r.RGB_DXT1||e===r.RGBA_DXT1||e===r.RGBA_DXT3||e===r.RGBA_DXT5||e===r.RGB_PVRTC_4BPPV1||e===r.RGB_PVRTC_2BPPV1||e===r.RGBA_PVRTC_4BPPV1||e===r.RGBA_PVRTC_2BPPV1||e===r.RGBA_ASTC||e===r.RGB_ETC1||e===r.RGB8_ETC2||e===r.RGBA8_ETC2_EAC||e===r.RGBA_BC7},isDXTFormat:function(e){return e===r.RGB_DXT1||e===r.RGBA_DXT1||e===r.RGBA_DXT3||e===r.RGBA_DXT5},isPVRTCFormat:function(e){return e===r.RGB_PVRTC_4BPPV1||e===r.RGB_PVRTC_2BPPV1||e===r.RGBA_PVRTC_4BPPV1||e===r.RGBA_PVRTC_2BPPV1},isASTCFormat:function(e){return e===r.RGBA_ASTC},isETC1Format:function(e){return e===r.RGB_ETC1},isETC2Format:function(e){return e===r.RGB8_ETC2||e===r.RGBA8_ETC2_EAC},isBC7Format:function(e){return e===r.RGBA_BC7},compressedTextureSizeInBytes:function(e,t,a){switch(e){case r.RGB_DXT1:case r.RGBA_DXT1:case r.RGB_ETC1:case r.RGB8_ETC2:return Math.floor((t+3)/4)*Math.floor((a+3)/4)*8;case r.RGBA_DXT3:case r.RGBA_DXT5:case r.RGBA_ASTC:case r.RGBA8_ETC2_EAC:return Math.floor((t+3)/4)*Math.floor((a+3)/4)*16;case r.RGB_PVRTC_4BPPV1:case r.RGBA_PVRTC_4BPPV1:return Math.floor((Math.max(t,8)*Math.max(a,8)*4+7)/8);case r.RGB_PVRTC_2BPPV1:case r.RGBA_PVRTC_2BPPV1:return Math.floor((Math.max(t,16)*Math.max(a,8)*2+7)/8);case r.RGBA_BC7:return Math.ceil(t/4)*Math.ceil(a/4)*16;default:return 0}},textureSizeInBytes:function(e,t,a,o){let i=r.componentsLength(e);return n["a"].isPacked(t)&&(i=1),i*n["a"].sizeInBytes(t)*a*o},alignmentInBytes:function(e,t,a){const n=r.textureSizeInBytes(e,t,a,1)%4;return 0===n?4:2===n?2:1},createTypedArray:function(e,t,a,o){let i;const c=n["a"].sizeInBytes(t);i=c===Uint8Array.BYTES_PER_ELEMENT?Uint8Array:c===Uint16Array.BYTES_PER_ELEMENT?Uint16Array:c===Float32Array.BYTES_PER_ELEMENT&&t===n["a"].FLOAT?Float32Array:Uint32Array;const s=r.componentsLength(e)*a*o;return new i(s)},flipY:function(e,t,a,n,o){if(1===o)return e;const i=r.createTypedArray(t,a,n,o),c=r.componentsLength(t),s=n*c;for(let r=0;r<o;++r){const t=r*n*c,a=(o-r-1)*n*c;for(let n=0;n<s;++n)i[a+n]=e[t+n]}return i},toInternalFormat:function(e,t,a){if(!a.webgl2)return e;if(e===r.DEPTH_STENCIL)return o["a"].DEPTH24_STENCIL8;if(e===r.DEPTH_COMPONENT){if(t===n["a"].UNSIGNED_SHORT)return o["a"].DEPTH_COMPONENT16;if(t===n["a"].UNSIGNED_INT)return o["a"].DEPTH_COMPONENT24}if(t===n["a"].FLOAT)switch(e){case r.RGBA:return o["a"].RGBA32F;case r.RGB:return o["a"].RGB32F;case r.RG:return o["a"].RG32F;case r.R:return o["a"].R32F}if(t===n["a"].HALF_FLOAT)switch(e){case r.RGBA:return o["a"].RGBA16F;case r.RGB:return o["a"].RGB16F;case r.RG:return o["a"].RG16F;case r.R:return o["a"].R16F}return e}};t["a"]=Object.freeze(r)},e53f:function(e,t,a){"use strict";var n=a("ee1e"),o=a("77af"),r=a("cef5"),i=a("670c"),c=a("be18"),s=a("abab"),l=a("d0c2"),u=a("535a"),p=a("2f63"),h=a("c52f"),g=a("d2c7"),d=a("81d7"),f=a("473c"),m=a("0123"),y=a("93da"),_=a("9251"),b=a("29bd"),T=a("1b8d"),E=a("b48e");function A(e,t){const a=new f["a"];a.position=new d["a"]({componentDatatype:s["a"].DOUBLE,componentsPerAttribute:3,values:e});const n=t.length,o=a.position.values.length/3,i=e.length/3,c=i/n,l=m["a"].createTypedArray(o,2*n*(c+1));let u,p,h=0;u=0;let y=u*n;for(p=0;p<n-1;p++)l[h++]=p+y,l[h++]=p+y+1;for(l[h++]=n-1+y,l[h++]=y,u=c-1,y=u*n,p=0;p<n-1;p++)l[h++]=p+y,l[h++]=p+y+1;for(l[h++]=n-1+y,l[h++]=y,u=0;u<c-1;u++){const e=n*u,t=e+n;for(p=0;p<n;p++)l[h++]=p+e,l[h++]=p+t}const _=new g["a"]({attributes:a,indices:m["a"].createTypedArray(o,l),boundingSphere:r["a"].fromVertices(e),primitiveType:T["a"].LINES});return _}function P(e){e=Object(u["a"])(e,u["a"].EMPTY_OBJECT);const t=e.polylinePositions,a=e.shapePositions;this._positions=t,this._shape=a,this._ellipsoid=h["a"].clone(Object(u["a"])(e.ellipsoid,h["a"].WGS84)),this._cornerType=Object(u["a"])(e.cornerType,l["a"].ROUNDED),this._granularity=Object(u["a"])(e.granularity,y["a"].RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeOutlineGeometry";let n=1+t.length*c["a"].packedLength;n+=1+a.length*i["a"].packedLength,this.packedLength=n+h["a"].packedLength+2}P.pack=function(e,t,a){let n;a=Object(u["a"])(a,0);const o=e._positions;let r=o.length;for(t[a++]=r,n=0;n<r;++n,a+=c["a"].packedLength)c["a"].pack(o[n],t,a);const s=e._shape;for(r=s.length,t[a++]=r,n=0;n<r;++n,a+=i["a"].packedLength)i["a"].pack(s[n],t,a);return h["a"].pack(e._ellipsoid,t,a),a+=h["a"].packedLength,t[a++]=e._cornerType,t[a]=e._granularity,t};const w=h["a"].clone(h["a"].UNIT_SPHERE),O={polylinePositions:void 0,shapePositions:void 0,ellipsoid:w,height:void 0,cornerType:void 0,granularity:void 0};P.unpack=function(e,t,a){let n;t=Object(u["a"])(t,0);let o=e[t++];const r=new Array(o);for(n=0;n<o;++n,t+=c["a"].packedLength)r[n]=c["a"].unpack(e,t);o=e[t++];const s=new Array(o);for(n=0;n<o;++n,t+=i["a"].packedLength)s[n]=i["a"].unpack(e,t);const l=h["a"].unpack(e,t,w);t+=h["a"].packedLength;const g=e[t++],d=e[t];return Object(p["a"])(a)?(a._positions=r,a._shape=s,a._ellipsoid=h["a"].clone(l,a._ellipsoid),a._cornerType=g,a._granularity=d,a):(O.polylinePositions=r,O.shapePositions=s,O.cornerType=g,O.granularity=d,new P(O))};const R=new o["a"];P.createGeometry=function(e){const t=e._positions,a=Object(n["a"])(t,c["a"].equalsEpsilon);let r=e._shape;if(r=b["a"].removeDuplicatesFromShape(r),a.length<2||r.length<3)return;_["a"].computeWindingOrder2D(r)===E["a"].CLOCKWISE&&r.reverse();const i=o["a"].fromPoints(r,R),s=b["a"].computePositions(a,r,i,e,!1);return A(s,r)},t["a"]=P}}]);